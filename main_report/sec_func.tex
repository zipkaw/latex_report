\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:func}

В данном разделе модули описаны с точки зрения разработки функций, которые реализуются в
дипломном проекте. Функциональное проектирование нацелено на создание корректно и
эффективно работающего проекта. Представление необходимого функционала~-- основная задача
текущего раздела. После анализа требуемых для реализации программного продукта
функций, было решено разбить программу на следующие модули:

\begin{itemize}
    \item модуль \moduleCfg;
    \item модуль \moduleXml;
    \item модуль \moduleSettingsApply;
    \item модуль \moduleRecvPackets;
    \item модуль \moduleThreads;
    \item модуль \moduleProcessPackets;
    \item модуль \moduleDataStoring;
    \item модуль \moduleOsal;
    \item модуль \moduleLog.
\end{itemize}

Каждый из модулей, который описан в контексте данного дипломного проекта,
относится к одному из укрупненных блоков. В соответствии с общим стилем
названий функций, каждый блок имеет свой уникальный префикс, который
отделяется от основного названия функции символом <<\_>>.
Исключением являются вспомогательные блоки.
Также каждая из функций может иметь один или несколько суффиксов,
которые по аналогии с префиксами отделяются от основного
названия специальным символом <<\_>>.
Подобный стиль именования позволяет обеспечить уникальность среди всех функций,
упрощает разработку и отладку всей системы, а также помогает разработчику
понять, воздействие какого модуля привело к подобному поведению.

В системе существуют межпроцессорные области, память которых может использоваться одновременно несколькими потоками на любом ядре в контексте всего SoC.
Такой подход дает преимущество одновременного доступа к памяти из разных участков программного кода, однако требует защиты с
помощью примитивов синхронизации, таких как критические секции или блокировки
чтения-записи.
Любой из указанных примитивов позволяет избежать одновременного изменения данных,
но последний вариант помогает получать множественный доступ к данным на чтение
в один момент времени, тогда как остальные способны обеспечивать только атомарный доступ.

Все описанные в данном разделе функции разрабатывались автором дипломного проекта.

\nomenclaturex{SoC}{System on a Chip}{система на кристалле, СнК}

Алгоритм получения и обработки данных представлен на схеме
данных \dataScheme. Диаграммы последовательности работы с \cid-файлом и
приема и обработки GOOSE-пакета приведены
на чертежах \seqIcdScheme\ и \seqGooseScheme\ соответственно.

\subsection{Модуль \moduleSettingsApply}

Модуль \moduleSettingsApply\ является одной из частей блока приема и обработки
GOOSE-пакетов, поэтому все функции текущего модуля используют его префикс
\lstinline{gooseInput_}.

Функция \lstinline{gooseInput_mapMemory_private} производит начальное взаимодействие
с межпроцессорными областями, которые необходимы для работы модулей
\moduleRecvPackets, \moduleThreads\ и \moduleProcessPackets, а также
сохраняет указатели на начало
межпроцессорных областей.
Для блока приема и обработки GOOSE-пакетов это
межпроцессорные области \lstinline{SHMEM_CONFIG_DATA} и \lstinline{SHMEM_INPUTS_DATA}.

В каждом блоке есть аналогичная функция, которая выполняет необходимые действия
по инициализации областей хранения данных.

В качестве параметров в функцию передается указатель \lstinline{h} на структуру
\lstinline{headers_pack_t}. В случае успешной инициализации в нее записываются
дескрипторы межпроцессорных областей, а также указатели
для доступа к данным, которые они хранят.

Функция имеет тип возвращаемого значения \lstinline{bool} и возвращает
\lstinline{true} в случае успешного получения указателей на начало межпроцессорных
областей и \lstinline{false} в противном случае.

Название описанной функции содержит суффикс \lstinline{_private},
поскольку она является статической функцией модуля. Поэтому реализация
должна быть использована только внутри этого блока.

Функция \lstinline{gooseInput_subscribe_private} подписывается на
изменение данных по индексам в области \lstinline{SHMEM_PROCESS_DATA},
которая является межпроцессорной.

Технология с отправкой модулю подписок определенных индексов связана с тем,
что данных в системе очень большое количество, ими надо обмениваться с помощью межпроцессорных очередей, а очереди имеют ограничения по размеру, собственную глубину.
Пересылать каждый раз огромные объемы данных является затратным по времени и
ресурсам, поэтому концепция индексов и возможность подписки на них необходима
для отправки и обработки только конкретных данных,
ускорения работы программы, упрощения разработки модулей и простоты обработки полученных данных.

В качестве параметров функция принимает структуру \lstinline{goose_input_t}~-- базовую структуру блока приема и обработки GOOSE-пакетов, которая включает следующие поля:

\begin{itemize}
    \item \lstinline{header}~-- указатель на структуру \lstinline{headers_pack_t} заголовочных файлов всех ресурсов модуля;
    \item \lstinline{param_struct}~-- указатель на структуру \lstinline{gooseInput_base_t} передаваемых параметров в функцию инициализации модуля приема и обработки GOOSE-пакетов.
\end{itemize}

Функция формирует сообщение с индексами для подписки модулю подписок и отправляет его в локальную очередь \lstinline{LOCAL_QUEUE_SUBSCRIPTION}. При корректной отправке сообщения, которая реализована с помощью макроса системы \lstinline{MQ_PUT}, возвращается \lstinline{true}, при ошибке отправки получаем \lstinline{false}.

Функция \lstinline{gooseInput_init} инициализирует блок приема и обработки GOOSE-пакетов. Она занимается проверкой всех глобальных
переменных, флагов, дескрипторов очередей, проводит инициализацию всего вышеперечисленного. Основной задачей является заполнение
глобальной структуры \lstinline{moduleParam} типа \lstinline{goose_input_t} основными настройками блока приема и обработки GOOSE-пакетов. В функции вызываются две
вспомогательные процедуры модуля: \lstinline{gooseInput_interfaceCreateOk} и \lstinline{gooseInput_deinitInterfaceCreate}.
В качестве входного параметра \lstinline{param} принимается
константный указатель на структуру
\lstinline{gooseInput_base_t}, которая содержит данные для заполнения \lstinline{moduleParam}.

Структура типа \lstinline{gooseInput_base_t} имеет следующие поля:

\begin{itemize}
    \item \lstinline{processTaskParams}~-- параметры задачи \lstinline{processTask};
    \item \lstinline{subscriptionTaskParams}~-- параметры задачи \lstinline{subscriptionTask};
    \item \lstinline{timerProcessTaskParams}~-- параметры задачи \lstinline{timerProcessTask};
    \item \lstinline{queueParams}~-- параметры очереди \lstinline{QUEUE_GOOSE_IN};
    \item \lstinline{lpdhSimIdx}~-- индекс в общей модели данных, по которому располагается флаг симуляции;
    \item \lstinline{vlanId}~-- идентификатор виртуальной локальной сети для модели;
    \item \lstinline{dstMac}~-- MAC-адрес назначения, используется для фильтрации принимаемых пакетов;
    \item \lstinline{time_ethernet_load}~-- время эмуляции нагрузки для модели;
    \item \lstinline{time_ethernet_idle}~-- время простоя для модели.
\end{itemize}

В качестве возвращаемого значения функции \lstinline{gooseInput_init}
используется перечисление \lstinline{gooseInput_retCode_t}. Оно является общим
для многих функций текущего блока и содержит элементы, описанные
в таблице~\ref{table:func:gooseInputRetCodeElems}.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{gooseInput_retCode_t}}
    \label{table:func:gooseInputRetCodeElems}
    \begin{tabular}{| >{\raggedright}m{0.6\textwidth}
                    | >{\raggedright\arraybackslash}m{0.347\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$GOOSE_INPUT_RET_CODE_OK$ &
        Отсутствие ошибок, функция успешно завершена
        \\

        \hline
        \lstinline[]$GOOSE_INPUT_RET_CODE_CREATE_ERROR$ &
        Ошибка создания необходимых ресурсов модуля
        \\

        \hline
        \lstinline[]$GOOSE_INPUT_RET_CODE_INIT_ERROR$ &
        Ошибка инициализации модуля
        \\

        \hline
        \lstinline[]$GOOSE_INPUT_RET_CODE_OPEN_ERROR$ &
        Ошибка открытия необходимых ресурсов модуля
        \\

        \hline
        \lstinline[]$GOOSE_INPUT_RET_CODE_ERROR_START$ &
        Ошибка старта модуля
        \\

        \hline
        \lstinline[]$GOOSE_INPUT_RET_CODE_ERROR_DEINIT$ &
        Ошибка деинициализации модуля
        \\

        \hline
    \end{tabular}
\end{table}

В результате работы \lstinline{gooseInput_init} ожидается
\lstinline{GOOSE_INPUT_INIT_OK} в случае успеха или один из перечисленных
в таблице~\ref{table:func:gooseInputRetCodeElems} кодов ошибок в остальных
случаях.
Отсутствие суффикса указывает на область видимости, доступную другим модулям.

Функция \lstinline{gooseInput_deinit} используется для деинициализации модуля приема и обработки GOOSE-пакетов. Функция занимается очисткой всех внутренних ресурсов:
списков, массивов, остановкой работы потоков, удалением созданных локально очередей сообщений, событий, примитивов синхронизации, освобождением межпроцессорной памяти, которая занята текущим модулем.
Также в результате работы происходит удаление созданных таймеров и освобождение
сетевых сокетов.

Для возможности корректного завершения задач блока текущая
функция отправляет сообщения в очереди, с которыми связан модуль.
Подобный механизм необходим для корректного освобождения ресурсов части
операционных систем, а также для повышения стабильности работы системы.
В случае, если какой-либо из потоков не смог корректно завершиться,
он будет принудительно удален по истечении определенного производителем срока.

В качестве параметров функция принимает время ожидания завершения модуля до принудительного удаления задач в миллисекундах и флаг, определяющий, необходима ли полная деинициализация модуля. Полная деинициализация отличается от обычной удалением созданных внутренних очередей и освобождением памяти.

Функция \lstinline{gooseInput_deinit} возвращает значение типа \lstinline{gooseInput_retCode_t}, которое может быть представлено \lstinline{GOOSE_INPUT_RET_CODE_OK} при успешной работе или
каким-либо другим значением из таблицы~\ref{table:func:gooseInputRetCodeElems}
в остальных случаях.

Функция \lstinline{gooseInput_initModel} является функцией инициализации блока приема и обработки GOOSE-пакетов.
Она эмулирует работу модуля для создания приблизительного эквивалента нагрузки на
целевую систему и
упрощает параллельную разработку других модулей. Особенностью является то, что нет необходимости иметь полную реализацию модуля приема и обработки GOOSE-пакетов для разработки и тестирования системы.

Передаются в функцию параметры в виде указателя \lstinline{param} на константную структуру типа \lstinline{gooseInput_base_t}. Она описывает приоритеты и
размеры стеков для каждой из создаваемых функций потоков
операционной системы.
Возвращаемое значение функции имеет тип \lstinline{gooseInput_retCode_t} и равняется \lstinline{GOOSE_INPUT_INIT_OK} при успешном выполнении. Остальные значения
имеют отрицательные значения и описаны
в таблице~\ref{table:func:gooseInputRetCodeElems}.

Функция \lstinline{gooseInput_interfaceCreateOk} проверяет успешность создания
ресурсов блока. Аналогичные интерфейсы имеются и в остальных модулях, которые
взаимодействуют с различными ресурсами системы с помощью дескрипторов.
Текущая функция принимает указатель \lstinline{h}
на структуру типа \lstinline{headers_pack_t} и выполняет проверку
на корректность дескрипторов ресурсов для внутреннего использования:
таймеров, очередей сообщений и событий.
Типом возвращаемого значения является \lstinline{bool}, следовательно при корректной работе функция вернет \lstinline{true}, а \lstinline{false} при ошибке.

Функция \lstinline{gooseInput_interfaceOpenOk} работает аналогично предыдущей
функции:
проверяет успешность открытия ресурсов блока, созданных другими модулями.
Анализируются очереди, области разделяемой памяти и примитивы синхронизации
в виде блокировок чтения-записи. Функция принимает указатель \lstinline{h}
на структуру типа \lstinline{headers_pack_t}
с дескрипторами внутренних ресурсов модуля и выполняет проверку
на их открытие.
Тип возвращаемого значения~-- \lstinline{bool}, следовательно при условии, что
все ресурсы успешно открыты, функция вернет \lstinline{true}, а в случае,
если хоть один ресурс не будет корректно открыт, вернется \lstinline{false}.
Подобные функции имеются в остальных модулях системы,
которые производят открытие ресурсов для внутреннего использования.

Функция \lstinline{gooseInput_deinitInterfaceCreate} занимается освобождением созданных модулем ресурсов. В ней происходит удаление очередей, таймеров
и примитивов синхронизации.
Функция принимает указатель \lstinline{h} на структуру типа
\lstinline{headers_pack_t} с дескрипторами ресурсов для внутреннего использования
модуля.
В результате работы функция ничего не возвращает, но удаляет те ресурсы,
которые все еще не были удалены.
Данная функция является типовой и имеется в каждом модуле системы,
который создает ресурсы для внутреннего использования.

Функция \lstinline{gooseInput_deinitInterfaceOpen} производит закрытие ресурсов модуля перед удалением. Правильным в программировании является отчистка ресурсов модуля после их закрытия, а удаление открытых ресурсов может повлечь непредсказуемое поведение системы. Функция закрывает очереди, отдает блокировки чтения-записи системе и занятую ранее память. Она принимает указатель на структуру типа \lstinline{headers_pack_t} с указателями на дескрипторы внутренних ресурсов модуля. Тип возвращаемого значения~-- \lstinline{void}, это значит, что функция ничего не вернет, а лишь закроет ресурсы, если будет, что закрывать, или просто ничего не сделает. Префикс \lstinline{gooseInput_} указывает на принадлежность к модулю приема и обработки GOOSE-пакетов. Аналогичная функция имеется в каждом модуле системы, в котором есть внутренние ресурсы.

Функция \lstinline{gooseInput_initInterfaceCreate} является функцией создания
ресурсов для дальнейшего использования модулем.
Она создает внутренние ресурсы, такие как очереди, события, таймеры.
В качестве аргументов функция принимает указатель \lstinline{param}
на структуру типа \lstinline{goose_input_t}~-- структуру
c входными параметрами блока. Функция заполняет необходимые поля
данной структуры корректными значениями. Она ничего не возвращает
как при успешном создании всех ресурсов, так и при возникновении ошибки.
Разработчик может узнать, при создании какого ресурса возникла проблема,
с помощью анализа результатов работы модуля \moduleLog.
Такой вариант возвращаемого
значения является вынужденным, поскольку функция вызывается в потоке инициализации,
а модуль не должен никогда прекращать свою работу, следовательно, критических ошибок
быть не должно. Аналогичная функция имеется в каждом модуле системы,
которому необходимо произвести создание ресурсов для внутреннего и внешнего
использования.

Функция \lstinline{gooseInput_initInterfaceOpen} является функцией открытия
внутренних ресурсов модуля. Для того, чтобы модуль мог взаимодействовать с
данными из общей памяти, получать или отправлять информацию в ранее созданные
очереди, необходимо открыть внутренние ресурсы. Функция открывает блокировки
чтения-записи, очереди и предоставляет доступ к двум типам памяти:
\lstinline{SHMEM_CONFIG_DATA} и \lstinline{SHMEM_INPUTS_DATA}.
В качестве параметров в функцию поступает указатель \lstinline{h} на структуру
типа \lstinline{headers_pack_t} с дескрипторами ресурсов, используемых модулем.
В результате работы функция ничего не возвращает, но при необходимости открывает
ресурсы модуля для внутреннего использования. Аналогичная функция имеется
в каждом модуле системы, который взаимодействует с внешними по отношению к блоку
модулями.

Функция \lstinline{gooseIn_getConfigureData_private} используется для считывания данных из модуля \moduleCfg. В качестве параметров принимается указатель на структуру \lstinline{h} типа \lstinline{headers_pack_t}. Данная функция вызывается при старте прибора и перезагрузке блока приема и обработки GOOSE-пакетов. Тип возвращаемого
значения функции~-- \lstinline{bool}. При успешном считывании конфигурационных
данных и проверке их на корректность
она возвращает \lstinline{true}, при ошибке~-- \lstinline{false}.

Функция \lstinline{gooseInput_getHeaderPack} предназначена для получение указателя
на структуру типа \lstinline{headers_pack_t}. Она не принимает никаких параметров
и обеспечивает доступ к внутреннему дескриптору модуля.

Структура типа \lstinline{headers_pack_t} является основной структурой дескрипторов и текущего состояния модуля и имеет следующие поля:

\begin{itemize}
    \item \lstinline{receivers[NET_ETH_COUNT]}~-- массив типа \lstinline{GooseReceiver} библиотеки \libIec, размер которого равен количеству физических сетевых интерфейсов, по которым могут приходить пакеты;
    \item \lstinline{gooseInputEvent}~-- дескриптор события типа \lstinline{eventHandle_t} для синхронизации работы блока;
    \item \lstinline{queues}~-- информация о необходимых блоку очередях сообщений, имеет тип \lstinline{queues_t};
    \item \lstinline{shms}~-- информация о необходимых блоку областях разделяемой памяти, имеет тип \lstinline{shms_t};
    \item \lstinline{sems}~-- информация о необходимых блоку блокировках чтения-записи, имеет тип \lstinline{sems_t};
    \item \lstinline{tasks}~-- информация о необходимых блоку задачах, имеет тип \lstinline{tasks_t};
    \item \lstinline{memoryMaps}~-- информация о необходимых блоку указателях на начало данных в областях разделяемой памяти, имеет тип \lstinline{memoryMaps_t};
    \item \lstinline{isInited}~-- статус инициализации необходимых ресурсов текущего блока, \lstinline{true} соответствует статусу успешной инициализации;
    \item \lstinline{isStarted}~-- статус запуска потоков модуля, \lstinline{true} соответствует тому, что запуск успешно пройден;
    \item \lstinline{isNeedToStop}~-- статус необходимости остановки работы блока,\lstinline{false} соответствует тому, что блок должен работать в штатном режиме;
    \item \lstinline{isSimulation}~-- статус включения режима симуляции, \lstinline{true} соответствует режиму <<Симуляция включена>>;
    \item \lstinline{gooseInputHead}~-- голова вспомогательного списка модуля приема и обработки GOOSE-пакетов, имеет тип \lstinline{gooseInput_gooseCfg_t};
    \item \lstinline{sockets[NET_ETH_COUNT]}~-- массив дескрипторов сокетов для взаимодействия, имеет тип \lstinline{netSock_t}.
\end{itemize}

Структура типа \lstinline{queues_t} представляет собой совокупность дескрипторов всех очередей, необходимых для работы блока приема и обработки GOOSE-пакетов, и включает следующие поля:

\begin{itemize}
    \item \lstinline{gooseIn}, тип определяется макросом \lstinline{MQ_HANDLE}~-- дескриптор очереди \lstinline{QUEUE_GOOSE_IN};
    \item \lstinline{subscription}, тип определяется макросом \lstinline{MQ_HANDLE}~-- дескриптор очереди \lstinline{QUEUE_SUBSCRIPTION_IPC};
    \item \lstinline{timerProcess}, тип определяется макросом \lstinline{MQ_HANDLE}~-- дескриптор очереди \lstinline{QUEUE_TIMER_PROCESS}.
\end{itemize}

Структура типа \lstinline{shms_t} представляет собой совокупность дескрипторов всех областей разделяемой памяти, которые необходимы для работы блока приема и обработки GOOSE-пакетов, и включает следующие поля:

\begin{itemize}
    \item \lstinline{configData} типа \lstinline{shmHandle_t}~-- дескриптор области памяти \lstinline{SHMEM_CONFIG_DATA};
    \item \lstinline{inputsData} типа \lstinline{shmHandle_t}~-- дескриптор области памяти \lstinline{SHMEM_INPUTS_DATA}.
\end{itemize}

Структура типа \lstinline{sems_t} представляет собой совокупность дескрипторов блокировок чтения-записи, которые необходимы для работы блока приема и обработки GOOSE-пакетов, и включает следующие поля:

\begin{itemize}
    \item \lstinline{configData}, тип определяется макросом \lstinline{RWSEM_HANDLE}~-- дескриптор блокировки чтения-записи \lstinline{SEM_CONFIG_DATA};
    \item \lstinline{inputsData}, тип определяется макросом \lstinline{RWSEM_HANDLE}~-- дескриптор блокировки чтения-записи \lstinline{SEM_INPUTS_DATA}.
\end{itemize}

Структура типа \lstinline{tasks_t} представляет собой совокупность дескрипторов задач, которые необходимы для работы блока приема и обработки GOOSE-пакетов, и содержит следующие поля:

\begin{itemize}
    \item \lstinline{processTask} типа \lstinline{taskHandle_t *}~-- массив дескрипторов задач потоков \lstinline{processTask} размером \lstinline{NET_ETH_COUNT};
    \item \lstinline{subscriptionTask} типа \lstinline{taskHandle_t}~-- дескриптор задачи потока \lstinline{subscriptionTask};
    \item \lstinline{timerProcessTask} типа \lstinline{taskHandle_t}~-- дескриптор задачи потока \lstinline{timerProcessTask}.
\end{itemize}

Структура типа \lstinline{shms_t} представляет собой совокупность указателей всех областей разделяемой памяти, которые необходимы для работы блока приема и обработки GOOSE-пакетов, и включает следующие поля:

\begin{itemize}
    \item \lstinline{configData} типа \lstinline{void *}~-- указатель на начало области памяти \lstinline{SHMEM_CONFIG_DATA};
    \item \lstinline{inputsData} типа \lstinline{void *}~-- указатель на начало области памяти \lstinline{SHMEM_INPUTS_DATA}.
\end{itemize}

Функция \lstinline{gooseInput_deinit_private} занимается удалением созданных блоком ресурсов. В качестве параметра принимает указатель \lstinline{param} типа
\lstinline{goose_input_t} на структуру дескрипторов ресурсов блока приема и обработки GOOSE-пакетов. Функция ничего не возвращает, но удаляет или закрывает ресурсы,
если это возможно, а также записывает в необходимые элементы разделяемой памяти
значения \lstinline{QUALITY_VALIDITY_INVALID}.

\subsection{Модуль \moduleRecvPackets}

Функция \lstinline{gooseInput_processGoosePacket}~-- поток блока приема и обработки GOOSE-пакета. Он взаимодействует с модулем \moduleOsal\ и производит получение и фильтрацию пакета. В качестве принимаемого значения~-- указатель \lstinline{param} на структуру
\lstinline{goose_inputWithIdx_t} дескрипторов ресурсов модуля с индексом задачи. Для начала в функции открывается сессия для взаимодействия с сетевым стеком. Это особенность системы, с которой начинают работать все потоки с подобной логикой. Далее в функции происходит создание сокета на получение GOOSE-пакета, установка необходимых флагов приема. При ошибке создания или установки флагов происходит закрытие и отчистка созданных ранее ресурсов. Далее поток ожидает принятие пакета. После корректного принятия пакет отправляется на обработку в функцию \lstinline{gooseInput_processGoosePkt_private}. Процесс никогда не заканчивается и повторяется в бесконечном цикле. Единственный способ покинуть поток приема и обработки GOOSE-пакета~-- установить флаг \lstinline{isNeedToStop}, который является элементом структуры, передаваемой в параметры, в параллельном потоке. Такая технология создана для возможности иметь контроль над работой потока, не прерывая его по причинам некорректного принятия или ошибке открытия сокета. В последних случаях произойдет отбрасывание пакета или повторное открытие сокета. Как было сказано выше, предполагается, что модуль не будет прекращать свою работу, следовательно, данная функция имеет тип возвращаемого значения \lstinline{void} и завершается лишь при установке необходимого флага. Данная функция является единственной, которая имеет прямую взаимосвязь с принимаемыми пакетами.

\subsection{Модуль \moduleThreads}

Функция \lstinline{gooseInput_start} является процедурой запуска блока приема и
обработки GOOSE-пакетов. Реализация функции должна иметь защиту от
утечек памяти. Например, с помощью проверки статуса модуля:
нельзя повторно инициализировать модуль без его предварительной деинициализации.

В случае успешности прохождения всех проверок вызывается вспомогательная
функция инициализации
интерфейса \lstinline{gooseInput_initInterfaceOpen}. Далее происходит создание
необходимых потоков модуля, которые работают параллельно, взаимодействуют между собой и реализуют необходимую бизнес-логику всего блока.
Потоки используются
для приема новых GOOSE-сообщений, их разбора, извлечения значений в соответствии с текущей конфигурацией, их записи в модуль \moduleDataStoring,
взаимодействия с модулем подписок, принятия измененных данных через межпроцессорные очереди и их применение, для непосредственной
работы с типом сообщений \lstinline{CDM_QUALITY} и для выполнения действий при истечении времени таймера.

В функцию передается параметр \lstinline{param} в виде указателя на структуру типа \lstinline{gooseInput_base_t}.
Данная структура заполняется дескрипторами созданных задач для более простого и быстрого доступа в процессе разработки и отладки.
Возвращаемое значение функции является перечислением
\lstinline{gooseInput_retCode_t}, о котором было сказано выше. При успешном создании всех потоков и инициализации параметров, необходимых для запуска модуля, функция возвращает \lstinline{GOOSE_INPUT_RET_CODE_OK}. Остальные значения и их
причины возврата описаны в таблице~\ref{table:func:gooseInputRetCodeElems}.

Функция \lstinline{gooseInput_subscriptions} является потоком модуля приема и обработки GOOSE-пакета с логикой подписки. Ранее было описано, для чего использовался алгоритм подписок. В функции выполняются следующие действия:

\begin{enumerate_num}
    \item Происходит считывание данных из памяти модуля GOOSE, защищенной примитивами синхронизации.
    \item Вызывается функция \lstinline{gooseInput_subscribe_private}, в которой происходит подписка на индексы общей памяти \lstinline{SHMEM_PROCESS_DATA}.
    \item Поток ожидает получение параметров от модуля подписок в свою собственную очередь \lstinline{QUEUE_GOOSE_IN}.
    \item Выполняется проверка принятых данных на соответствие минимально допустимому размеру команды, при некорректном размере сообщение отбрасывается и происходит возвращение к моменту ожидания сообщения от модуля подписок.
    \item Из сообщения происходит извлечение команды, которая может быть двух типов: \lstinline{CMD_DATA_UPDATE_PROCESS} и \lstinline{CMD_INIT}.
    \item В случае, если тип команды \lstinline{CMD_DATA_UPDATE_PROCESS}, происходит обновление измененных данных по индексам \lstinline{SHMEM_PROCESS_DATA}.
    \item В случае, если тип команды \lstinline{CMD_INIT}, выполняется переконфигурация модуля в соответствии с обновленными настройками.
\end{enumerate_num}

Существует вариант, когда разрабатываемому модулю приходит некорректное сообщение от модуля подписок. Тогда оно просто отбрасывается, сопровождаясь сообщением об ошибке. Как уже было сказано выше, единственным способом выхода из работающего потока является установка флага \lstinline{isNeedToStop} из текущего или другого потока. Планируется, что модуль не будет прекращать свою работу, следовательно, данная функция имеет тип возвращаемого значения \lstinline{void} и завершается лишь при установке необходимого флага.

Функция \lstinline{gooseInput_timerProcessing} является потоком для выполнения действий при истечении времени таймера. В параметры функция принимает указатель \lstinline{param} на структуру типа \lstinline{goose_input_t} с входными параметрами. Поток ожидает получения сообщения во внутреннюю очередь модуля \lstinline{QUEUE_TIMER_PROCESS} от других модулей системы, проверяет принятое сообщение на корректность по длине. При получении ошибочного сообщения, поток возвращается в состояние ожидания получения пакета. Если удалось получить корректное сообщение, то происходит получение данных по индексам из таблицы индексов общей памяти. У этих данных проверяется тип, если он соответствует \lstinline{CM_QUALITY}, то устанавливается в значение \lstinline{QUALITY_VALIDITY_QUESTIONABLE}.
Установка качества в значение <<Вероятное>> означает истечение срока корректности данных и необходимость получить новые значения.
Обращение к общей памяти защищено примитивами синхронизации. Регулирование работы потока происходит по таймеру, а не по флагу, как в предыдущих случаях. Описываемая функция ничего не возвращает, что определяется необходимостью потока работать не переставая.

Существуют функции, которые были созданы не для работы блока приема и обработки GOOSE-пакетов, а для проверки нагрузки на систему, упрощения тестирования и параллельной разработки. Они представляют собой упрощенную модель работы модуля без конкретизации определенной логики. К таким функциям относятся:

\begin{itemize}
    \item \lstinline{gooseInput_subscriptionModelTask}~-- поток модуля \moduleRecvPackets\ для обработки подписок;
    \item \lstinline{gooseInput_ethernetModelTask}~-- поток модуля \moduleRecvPackets\ для эмуляции работы сетевого стека;
    \item \lstinline{gooseInput_inputModelTask}~-- поток модуля \moduleRecvPackets\ для приема данных.
\end{itemize}

Все описанные выше функции в качестве параметра принимают указатель \lstinline{param} на структуру типа \lstinline{goose_input_t}~-- тип структуры модуля c входными параметрами. Они ничего не возвращают в результате своей работы,
поскольку должны постоянно эмулировать нагрузку. Модель, созданная с помощью текущих и подобных функций в модулях, была первым этапом разработки сложной системы. Ее целью являлось отображение всех серьезных проблем, связанных с нагрузкой, и помощью с внесением доработок в будущую разработку. Модель позволила работать над проектом одновременно огромному числу разработчиков и тестировщиков. Однако недостатком такого подхода была стыковка всех компонентов системы, на которое ушло много времени. Одновременное обновление большого числа блоков также было сложной задачей.

Функция \lstinline{gooseInput_timer_cb} является обработчиком таймера. Суффикс \lstinline{_cb} указывает, что текущая процедура относится к функциям обратного вызова. Ее основной задачей
является передача в очередь \lstinline{QUEUE_TIMER_PROCESS} данных, которые подаются в качестве входных параметров и представлены указателем \lstinline{parameter} на локальную структуру \lstinline{gooseInput_gooseCfg_t} текущего модуля.
Аргумент имеет тип \lstinline{void *} для универсализации принимаемых
дескрипторов в пользовательские функции.
Функция обратного вызова используется для отслеживания времени жизни пришедшего GOOSE-пакета и ничего не возвращает в результате своей работы.

\subsection{Модуль \moduleProcessPackets}

Функция \lstinline{gooseInput_processGoosePkt_private} выполняет разбор GOOSE-пакета. В качестве параметров она принимает \lstinline{goose_receiver} типа
\lstinline{GooseReceiver}~-- дескриптор
для разбора GOOSE-пакета, \lstinline{buffer} типа \lstinline{uint8_t *}~-- указатель на буфер с полученным пакетом и \lstinline{len} типа \lstinline{uint32_t}~-- длина пришедших данных. Функция вызывает процедуру \lstinline{parseGooseMessage},
которая определена в \libIec\ и используется для обработки GOOSE-пакетов. Тип возвращаемого значения у функции~-- \lstinline{bool}. При успешном разборе пакета она возвращает
\lstinline{true}, при ошибке~-- \lstinline{false}.

Функция \lstinline{gooseInput_compareMmsAndCdm} выполняет сравнение типов данных MMS и CDM, соответствие которых определено в таблице~\ref{table:func:MmsCdmTypes}.
В качестве параметров принимаются указатель
\lstinline{mms_value} типа \lstinline{MmsValue} из \libIec, и номер типа данных
\lstinline{cdm_type} типа \lstinline{commonModel_type_t}. Функция возвращает значение типа
\lstinline{bool}: \lstinline{true} при совпадении типов и успешном выполнении
необходимой последовательности действий, \lstinline{false}~-- при ошибке или
несоответствии типов.

\nomenclaturex{CDM}{Common Data Model}{общая модель данных}

Функция \lstinline{gooseInput_convertWrite} преобразовывает типы MMS в типы CDM
в соответствии с таблицей~\ref{table:func:MmsCdmTypes} и записывает данные в память \lstinline{SHMEM_INPUTS_DATA}. В качестве входных параметров используются:

\begin{itemize}
    \item \lstinline{mms_value} типа \lstinline{MmsValue}, который определен в \libIec,~-- указатель на данные MMS, которые функция преобразует в CDM-формат и записывает в память;
    \item \lstinline{memory_offset} типа \lstinline{ptrdiff_t}~-- смещение в памяти \lstinline{SHMEM_INPUTS_DATA}, куда надо записать данные;
    \item \lstinline{type} типа \lstinline{commonModel_type_t}~-- тип данных CDM, который необходимо записать в память.
\end{itemize}

Данная функция возвращает тип \lstinline{bool}. Значение \lstinline{true} будет получено при успешном преобразовании типов и корректной записи в разделяемую память, при
ошибке одного из вышеперечисленных действий ожидается \lstinline{false}.

Тип \lstinline{commonModel_type_t} является перечислением, определяется в модуле \moduleDataStoring\ и может принимать значения, описанные в таблице~\ref{table:func:cmTypes}.

Функция \lstinline{gooseInput_convertWriteFull} является функцией проверки результата и обработки данных функции \lstinline{gooseInput_convertWrite}.

\begin{table}[ht]
    \caption{Соответствие типов MMS и CDM}
    \label{table:func:MmsCdmTypes}
    \begin{tabular}{| >{\raggedright}m{0.34\textwidth}
                    | >{\raggedright}m{0.26\textwidth}
                    | >{\raggedright\arraybackslash}m{0.32\textwidth}|}
        \hline
        \centering Название типа MMS
        & \centering Название типа CDM
        & \centering\arraybackslash Комментарий \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$MMS_BOOLEAN$ &
        \lstinline[]$CM_BOOL$ &
        \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$MMS_BIT_STRING$ &
        \lstinline[]$CM_QUALITY$ или
        \lstinline[]$CM_DP$ &
        Определяется размером \lstinline[]$MMS_BIT_STRING$
        \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$MMS_INTEGER$ &
        \lstinline[]$CM_INT$ &
        \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$MMS_UNSIGNED$ &
        \lstinline[]$CM_UNSIGNED$ &
        \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$MMS_UNSIGNED$ &
        \lstinline[]$CM_UNSIGNED$ &
        \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$MMS_STRING$ или
        \lstinline[]$MMS_VISIBLE_STRING$ &
        \lstinline[]$CM_STRING255$ или
        \lstinline[]$CM_STRING64$ &
        Определяется размером типа MMS
        \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$MMS_UTC_TIME$ &
        \lstinline[]$CM_IEC_TIME$ &
        \\

        \hline
    \end{tabular}
\end{table}

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{commonModel_type_t}}
    \label{table:func:cmTypes}
    \begin{tabular}{| >{\raggedright}m{0.33\textwidth}
                    | >{\raggedright\arraybackslash}m{0.617\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$CM_BOOL$ &
        Логический тип
        \\

        \hline
        \lstinline[]$CM_DP$ &
        Перечисление DbPos стандарта \iecStd
        \\

        \hline
        \lstinline[]$CM_UNSIGNED$ &
        Беззнаковое 32-битное число
        \\

        \hline
        \lstinline[]$CM_U32_100$ &
        Беззнаковое 32-битное число в процентах
        \\

        \hline
        \lstinline[]$CM_U32_1000$ &
        Беззнаковое 32-битное число в промилле
        \\

        \hline
        \lstinline[]$CM_INT$ &
        Знаковое 32-битное число
        \\

        \hline
        \lstinline[]$CM_INT64$ &
        Знаковое 64-битное число
        \\

        \hline
        \lstinline[]$CM_INT32_100$ &
        Знаковое 32-битное число в процентах
        \\

        \hline
        \lstinline[]$CM_INT32_1000$ &
        Знаковое 32-битное число в промилле
        \\

        \hline
        \lstinline[]$CM_QUALITY$ &
        Качество
        \\

        \hline
        \lstinline[]$CM_COMPLEX32_100$ &
        Комплексное знаковое 32-битное число в процентах
        \\

        \hline
        \lstinline[]$CM_COMPLEX32_1000$ &
        Комплексное знаковое 32-битное число в промилле
        \\

        \hline
        \lstinline[]$CM_STRING255$ &
        Строка длиной до 255 байт
        \\

        \hline
        \lstinline[]$CM_STRING64$ &
        Строка длиной до 64 байт
        \\

        \hline
        \lstinline[]$CM_IEC_TIME$ &
        Тип времени
        \\

        \hline
        \lstinline[]$CM_OBJREF_T$ &
        Ссылка на объект
        \\

        \hline
    \end{tabular}
\end{table}

Данная функция имеет тип возвращаемого значения \lstinline{bool}. Значение \lstinline{true} будет получено при успешной работе, при ошибке ожидается \lstinline{false}.
В качестве входных параметров используются:

\begin{itemize}
    \item \lstinline{mms_value} типа \lstinline{MmsValue}, который определен в \libIec,~-- указатель на MMS данные, которые представляют собой GOOSE-пакет;
    \item \lstinline{subscriber} типа \lstinline{GooseSubscriber}, который определен в \libIec,~-- указатель на структуру подписчика;
    \item \lstinline{ptr} типа \lstinline{gooseInput_gooseCfg_t}~-- указатель на структуру с данными модуля;
    \item \lstinline{cdmIdx} типа \lstinline{uint32_t}~-- индекс в памяти \lstinline{SHMEM_INPUTS_DATA}, куда производится запись данных из GOOSE-пакета.
\end{itemize}

Структура типа \lstinline{gooseInput_gooseCfg_t}~-- структура с данными ресурсов модуля, имеет следующие поля:

\begin{itemize}
    \item \lstinline{next} типа \lstinline{gooseInput_gooseCfg_t}~-- указатель на следующий элемент списка, который используется для реализации логики работы модуля;
    \item \lstinline{timer} типа \lstinline{timerHandle_t}~-- дескриптор таймера, используемого для измерения времени жизни принятых данных;
    \item \lstinline{stNum} типа \lstinline{uint32_t}~-- значение поля \lstinline{stNum} последнего успешно обработанного GOOSE-пакета; поле определено \iecStd;
    \item \lstinline{sqNum} типа \lstinline{uint32_t}~-- значение поля \lstinline{sqNum} последнего успешно обработанного GOOSE-пакета; поле определено \iecStd;
    \item \lstinline{confRev} типа \lstinline{uint32_t}~-- ожидаемое значение поля \lstinline{confRev} обрабатываемого GOOSE-пакета; поле определено \iecStd;
    \item \lstinline{reboot} типа \lstinline{bool}~-- статус перезагрузки устройства, которое отправляет GOOSE-пакеты;
    \item \lstinline{memoryMaps} типа \lstinline{memoryMaps_t}~-- адреса начала областей разделяемой памяти;
    \item \lstinline{varsCount} типа \lstinline{uint32_t}~-- количество элементов в массиве \lstinline{vars}, который определен в данной структуре;
    \item \lstinline{h} типа \lstinline{headers_pack_t *}~-- дескриптор внутренних ресурсов модуля;
    \item \lstinline{isPrevPacketSimulation} типа \lstinline{bool}~-- режим симуляции последнего успешно обработанного GOOSE-пакета;
    \item \lstinline{cdmIdx} типа \lstinline{uint32_t}~-- индекс в памяти \lstinline{SHMEM_INPUTS_DATA}, куда производится запись данных из GOOSE-пакета;
    \item \lstinline{vars} типа \lstinline{gooseInput_vars_t}~-- массив вспомогательных структур для записи данных из обработанного GOOSE-пакета.
\end{itemize}

Структура типа \lstinline{gooseInput_vars_t} является вспомогательной структура для записи данных из принятого GOOSE-пакета. Обычно заполняется данным в модуле
\moduleCfg. Содержит следующие поля:

\begin{itemize}
    \item \lstinline{cdmIdx} типа \lstinline{uint32_t}~--индекс общей модели данных;
    \item \lstinline{cdmType} типа \lstinline{commonModel_type_t}~-- тип данных в общей модели;
    \item \lstinline{nestingSize} типа \lstinline{uint8_t}~-- количество элементов, доступных для чтения по указателю \lstinline{nesting} данной структуры;
    \item \lstinline{nesting} типа \lstinline{uint8_t}~-- массив индексов для адресации данных в GOOSE-пакете.
\end{itemize}

Функция \lstinline{gooseInput_cmpMmsCdmWithCheck} обрабатывает результаты работы \lstinline{gooseInput_compareMmsAndCdm}. Основной ее задачей считается
получение значений вышеуказанной функции, выполнение дополнительных действий, предусмотренных логикой программы, таких как вывод ошибочных сообщений и завершение при некорректной работе. Типом возвращаемого значения является \lstinline{bool}. В результате успешного выполнения функции получаем \lstinline{true} при успешной работе, \lstinline{false} при возникновении ошибки.

В качестве входных параметров используются:

\begin{itemize}
    \item \lstinline{mms_value} типа \lstinline{MmsValue}, который определен в \libIec,~-- указатель на MMS данные, которые представляют собой полезную нагрузку GOOSE-пакета;
    \item \lstinline{subscriber} типа \lstinline{GooseSubscriber}, который определен в \libIec,~-- дескриптор подписчика;
    \item \lstinline{ptr} типа \lstinline{gooseInput_gooseCfg_t}~-- дескриптор данных текущего блока;
    \item \lstinline{vars} типа \lstinline{gooseInput_vars_t}~-- массив вспомогательных структур для записи данных, считанных из конфигурации.
\end{itemize}

Функция \lstinline{gooseInput_cmpMmsCdmWithCheckNoSave}~-- функция обработки результата функции \lstinline{gooseInput_compareMmsAndCdm} без дальнейшей записи в память и вывода сообщения при ошибке работы. Входные параметры текущей функции соответствуют входным параметрам функции \lstinline{gooseInput_cmpMmsCdmWithCheck},
которая описана выше. Типом возвращаемого значения является \lstinline{bool}. В результате успешного выполнения функции получаем \lstinline{true} при успешной работе, \lstinline{false} при возникновении ошибки.

Функция \lstinline{gooseInput_processTimerSaveStNumAndSqNum} используется для работы с таймером и сохранения значений \lstinline{stNum} и \lstinline{sqNum} в локальную структуру.
Как уже было сказано выше, данные поля имеются в каждом GOOSE-пакете и используются для отслеживания статуса принимаемых данных.
Для этой цели сохраняются значения данных полей предыдущего корректно принятого пакета. Если происходит сбой или несоответствие, то вновь прибывший GOOSE-пакет отбрасывается, считаясь ошибочным.
Если происходит увеличение \lstinline{sqNum} без изменения \lstinline{stNum},
дальнейший разбор прекращается, поскольку считается, что данные не изменились, а
только были подтверждены.
В качестве входных параметров в функцию подаются указатель \lstinline{subscriber} на структуру подписчика \lstinline{GooseSubscriber} и указатель \lstinline{ptr} на структуру
типа \lstinline{gooseInput_gooseCfg_t} с данными модуля приема и обработки GOOSE-пакетов. Текущая функция ничего не возвращает, а лишь записывает новые данные во внутреннее представление.

\subsection{Модуль \moduleDataStoring}

Функция \lstinline{dataStoring_gooseListener} является функцией обратного вызова и предназначена
для записи данных в разделяемую память \lstinline{SHMEM_INPUTS_DATA}. Функция анализирует принятый пакет на наличие
тестовых данных, выполняет проверки на соответствие типам MMS. Если
обработка полученной информации завершилась успешно, обработанные и проверенные данные будут записаны в общую память. Функция обратного вызова ничего не возвращает и завершает свою работу в случае получения некорректных данных, тестового пакета или успешного сохранения результатов в разделяемую память.
В качестве параметров функция принимает указатель \lstinline{parameter} типа
\lstinline{void *}, который подается в \lstinline{GooseSubscriber_setListener}
библиотеки \libIec\ при добавлении функции в список вызываемых при обработке.
Данный дескриптор предназначен для передачи программистом необходимой
дополнительной информации на этап сохранения и обработки.
Вторым аргументом является указатель \lstinline{subscriber} на локальную структуру
типа \lstinline{GooseSubscriber} с данными, считанными из конфигурации. Эта структура описана в библиотеке \libIec.

\subsection{Модуль \moduleOsal}

Во время написания системы разработчик вынужден взаимодействовать с разделяемой памятью, блокировками чтения-записи, событиями, мьютексами, таймерами, сетевым стеком и другими вспомогательными
инструментами. Как было описано ранее, текущий программный продукт разрабатывается сразу под несколько платформ, следовательно было принято решение вынести части кода,
которые зависимы от конкретных операционных систем, в отдельный модуль. Данное решение предоставляет универсальность разрабатываемому
программному продукту, а также возможность повторного использования остального
кода в дальнейшем.

\subsubsection{События}

События как примитивы синхронизации созданы с целью
добавления возможности мультиплексирования
фактов о возникновения явлений в системе.
Они могут быть использованы в качестве нотификаций одного потока другому
о возникновении события. Ожидающая события сторона может ждать возникновения
как одного, так и нескольких событий единовременно.

Функция \lstinline{eventCreate} используется для создания событий. Функция ничего не принимает, в качестве возвращаемого значения выступает дескриптор события типа \lstinline{eventHandle_t}. При ошибке создания возвращается \lstinline{NULL}.

Функция \lstinline{eventPost} генерирует событие. Она принимает в качестве параметров дескриптор события \lstinline{handle} типа \lstinline{eventHandle_t} и непосредственно
генерируемое событие \lstinline{event} типа \lstinline{uint32_t}. Функция ничего не возвращает и используется в связке с функцией ожидания события, которая описана ниже. Такой
механизм позволяет быстро узнавать о возникновении каких-либо ситуаций в разных частях программного обеспечения.

Функция \lstinline{eventPend} используется для ожидания события. В качестве входных параметров используются:

\begin{itemize}
    \item \lstinline{handle} типа \lstinline{eventHandle_t}~-- дескриптор созданного события;
    \item \lstinline{eventMask} типа \lstinline{uint32_t}~-- маска события;
    \item \lstinline{evtMode} типа \lstinline{eventMode_t}~-- режим ожидания события;
    \item \lstinline{tim} типа \lstinline{uint32_t}~-- таймаут в микросекундах.
\end{itemize}

Тип \lstinline{eventMode_t} представлен перечислением и может принимать одно из значений, описанных в таблице~\ref{table:func:eventMode}.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{eventMode_t}}
    \label{table:func:eventMode}
    \begin{tabular}{| >{\raggedright}m{0.2\textwidth}
                    | >{\raggedright\arraybackslash}m{0.747\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$evtModeAnd$ &
        Режим <<И>>, должны быть активны все биты, заданные маской события
        \\

        \hline
        \lstinline[]$evtModeOr$ &
        Режим <<ИЛИ>>, должен быть активен хотя бы один бит из маски события
        \\

        \hline
    \end{tabular}
\end{table}

В качестве таймаута могут подаваться значения \lstinline{EVENT_TIM_FOREVER}~-- бесконечное ожидание, \lstinline{EVENT_TIM_NO_WAIT}~-- неблокирующий вызов или
время ожидания в микросекундах.

Функция \lstinline{eventPend} имеет тип возвращаемого значения \lstinline{uint32_t} и выдает \lstinline{0} при отсутствии события при неблокирующем вызове или истечении времени ожидания. Если условия ожидания были выполнены, будут
возвращены все возникшие результирующие события, которые ожидались.

Функция \lstinline{eventDelete} занимается удалением события, если оно было создано ранее.
В качестве входного параметра
принимает дескриптор события \lstinline{handle} типа \lstinline{eventHandle_t}, который необходимо удалить. Возвращаемое значение отсутствует.

\subsubsection{Очереди}

Межпроцессорные очереди и внутренние очереди блока приема и обработки GOOSE-пакетов~-- удобный механизм передачи сообщений. Это является надежным и быстрым способом. В системе,
как уже было сказано выше, есть два типа очередей: внутренние очереди каждого модуля, которые создаются и удаляются в нем и которые используются для взаимодействия между частями этого самого модуля, и межпроцессорные очереди, которые создаются общим модулем запуска системы и используются для обмена сообщениями между разными ядрами системы. Функции работы с
очередями идентичны, однако у межпроцессорных имеется суффикс \lstinline{_ipc}.

Для универсализации дескрипторов для межпроцессорных и обычных очередей сообщений
вместо стандартных дескрипторов
\lstinline{mqIpcHandle_t} и \lstinline{mqHandle_t}
рекомендуется использовать \lstinline{MQ_HANDLE}. Этот вариант является более
универсальным и позволяет определить тип каждой очереди в одном файле,
а в случае необходимости быстро изменять тип без изменения мест использования.
Для реализации этого нужно
использовать универсальные макросы, которые с нулевыми потерями времени исполнения
позволят выполнять взаимодействие с дескриптором с помощью корректных функций:
обычных или межпроцессорных.

Функция создания очереди сообщений \lstinline{mqCreate} возвращает дескриптор созданной очереди типа \lstinline{mqHandle_t} при успешной работе, \lstinline{NULL} при ошибке.
В параметры принимает уникальное имя очереди \lstinline{name} типа \lstinline{const char *}, типичный размер сообщения \lstinline{messageSize} типа \lstinline{uint32_t} и глубину очереди
\lstinline{depth} типа \lstinline{uint32_t}.

Для работы с межпроцессорной очередью сообщений из того ядра, которое
не должно создавать ее, необходимо производить открытие, что обеспечивается с использованием функции \lstinline{mqOpen}. Она возвращает дескриптор открытой
очереди типа \lstinline{mqHandle_t} при успешной работе, \lstinline{NULL} при ошибке, а в качестве параметра принимает уникальное имя очереди \lstinline{name} типа
\lstinline{const char *}.
Для внутренних очередей также определена описанная функция с целью обеспечения
единого интерфейса взаимодействия.

Функция \lstinline{mqAlloc} предназначена для выделения памяти под сообщение в очереди. В качестве параметров принимает дескриптор очереди \lstinline{handle} типа \lstinline{mqHandle_t},
а также запрашиваемый размер памяти в байтах \lstinline{size} типа \lstinline{uint32_t}. При успешной работе функции вернется адрес выделенной памяти типа \lstinline{void *},
при ошибке~-- \lstinline{NULL}. Необходимо помнить об освобождении полученной памяти в случае, если сообщение не было отправлено по какой-либо причине.

Функция \lstinline{mqFree} используется для освобождения памяти, полученной \lstinline{mqAlloc}. Она ничего не возвращает, а лишь освобождает память, если такая была выделена.
В качестве принимаемого значения получает начальный адрес освобождаемой памяти \lstinline{ptr} типа \lstinline{void *}.

Для того, чтобы произвести отправку данных, их необходимо поместить в очередь с помощью функции \lstinline{mqPut}. Типом возвращаемого значения является \lstinline{mq_error_code_t}. Функция возвращает \lstinline{MQ_OK} при успешной отправке, иначе код ошибки, который представлен отрицательным значением в указанном перечислении.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{mq_error_code_t}}
    \label{table:func:mqErrorCode}
    \begin{tabular}{| >{\raggedright}m{0.55\textwidth}
                    | >{\raggedright\arraybackslash}m{0.397\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$MQ_OK$ &
        Отсутствие ошибок
        \\

        \hline
        \lstinline[]$MQ_ERROR_WRONG_HANDLE$ &
        Некорректный дескриптор очереди
        \\

        \hline
        \lstinline[]$MQ_ERROR_WRONG_BUFFER$ &
        Некорректный указатель на буфер с сообщением
        \\

        \hline
        \lstinline[]$MQ_ERROR_WRONG_SIZE$ &
        Некорректный размер сообщения
        \\

        \hline
        \lstinline[]$MQ_ERROR_TIMEOUT$ &
        Превышено время ожидания сообщения
        \\

        \hline
        \lstinline[]$MQ_ERROR_CANT_ALLOCATE_MEMORY$ &
        Невозможно выделить память для нового элемента очереди
        \\

        \hline
    \end{tabular}
\end{table}

Возможные возвращаемые коды ошибок представлены в таблице~\ref{table:func:mqErrorCode}.

Функция \lstinline{mqPut} в качестве входных параметров принимает:

\begin{itemize}
    \item \lstinline{handle} типа \lstinline{mqHandle_t}~-- дескриптор созданной очереди;
    \item \lstinline{buffer} типа \lstinline{const void *}~-- указатель на отправляемое сообщение;
    \item \lstinline{sz} типа \lstinline{uint32_t}~-- размер отправляемого сообщения;
    \item \lstinline{tim} типа \lstinline{uint32_t}~-- таймаут в микросекундах.
\end{itemize}

В качестве таймаута могут подаваться значения \lstinline{MQ_TIM_FOREVER}~-- бесконечное ожидание, \lstinline{MQ_TIM_NO_WAIT}~-- неблокирующий вызов или
время ожидания в микросекундах.

Существует функция, аналогичная вышеописанной~-- \lstinline{mqPutNc}. Она также занимается записью сообщения в очередь, однако без копирования, что делает ее быстрее и во многих
случаях удобнее. Параметры и возможные возвращаемые значения совпадают с функцией \lstinline{mqPut},
но в качестве аргумента \lstinline{buffer} она ожидает получить указатель на
буфер, который был предварительно выделен с помощью вызова \lstinline{mqAlloc}.

Для принятия сообщения его необходимо получить из очереди с помощью команды \lstinline{mqGet}, параметры которой представлены в следующем списке:

\begin{itemize}
    \item \lstinline{handle} типа \lstinline{mqHandle_t}~-- дескриптор созданной очереди;
    \item \lstinline{buffer} типа \lstinline{void *}~-- адрес буфера для сохранения полученного сообщения;
    \item \lstinline{sz} типа \lstinline{uint32_t}~-- максимальный размер ожидаемого сообщения;
    \item \lstinline{tim} типа \lstinline{uint32_t}~-- время ожидания сообщения в микросекундах.
\end{itemize}

Возможные значения таймаута совпадают с функцией \lstinline{mqPut}.

Функция возвращает данные типа \lstinline{int32_t}, которые являются размером
принятого сообщения в случае положительного числа, \lstinline{0} в случае
истечения времени ожидания сообщения и одно из значений кодов ошибок,
описанных в таблице~\ref{table:func:mqErrorCode}.

Существует функция, аналогичная вышеописанной~-- \lstinline{mqGetNc}. Она также занимается получением сообщения из очереди, однако отдает пользователю
указатель на полученные данные, а не копирует их в переданный ей буфер, что делает ее быстрее и во многих
случаях удобнее. Параметры и возможные возвращаемые значения совпадают с функцией \lstinline{mqGet}, за исключением следующих особенностей:

\begin{itemize}
    \item параметр \lstinline{buffer} имеет тип \lstinline{void **}~-- по этому адресу
    будет записан указатель на принятое сообщение, которое нужно освободить с помощью \lstinline{mqFree} после извлечения необходимых данных;
    \item отсутствует параметр \lstinline{sz} по причине константности его значения: размеру одного указателя.
\end{itemize}

По завершению работы необходимо обязательно закрыть открытые ресурсы. Функция \lstinline{mqClose} используется для закрытия очередей, которые были открыты с помощью функции
\lstinline{mqOpen}. В качестве параметра \lstinline{mqClose} принимает дескриптор очереди \lstinline{handle} типа \lstinline{mqHandle_t}. Функция ничего не возвращает, а лишь закрывает ранее
открытые ресурсы.

В случае создания и отсутствия необходимости дальнейшего использования необходимо
удалить выделенные ресурсы. Данным действием занимается функция \lstinline{mqDelete}, принимающая в параметры дескриптор очереди \lstinline{handle} типа \lstinline{mqHandle_t}. Она ничего не возвращает, а лишь удаляет выделенные ранее ресурсы.

\subsubsection{Мьютексы}

Мьютексом называют примитив синхронизации, обеспечивающий взаимное исключение исполнения критических участков кода. Он отличается от блокировки наличием владельца, который и должен его освобождать.
Как и очереди, текущий примитив синхронизации может быть предназначен как для
использования на одном ядре, так и на множестве. Последний вариант называется
межпроцессорным и имеет в названиях своих функций и типов суффикс \lstinline{_ipc}.

Создание мьютексов происходит с помощью функции \lstinline{mutexCreate}. Она возвращает дескриптор типа \lstinline{mutexHandle_t} в случае успешной работы и \lstinline{NULL}
при ошибке. В параметры передается уникальное имя мьютекса \lstinline{name} типа \lstinline{const char *}.

При работе с ресурсами данного типа на нескольких ядрах одновременно, после создания ресурса на одном ядре необходимо его открытие на остальных. Функция, занимающаяся открытием мьютекса, называется \lstinline{mutexOpen}. Она принимает в качестве параметра
уникальное имя мьютекса \lstinline{name} типа \lstinline{const char *} и возвращает дескриптор типа \lstinline{mutexHandle_t} в случае успешной работы, \lstinline{NULL} при ошибке.
Необходимо помнить, что если ресурс был открыт, то по окончании пользования, нужно произвести его закрытие.

Для сохранения совместимости интерфейсов многоядерных мьютексов и мьютексов
для работы на одном ядре текущая функция также реализуется для последнего варианта.

Для защиты ресурса от конкурентного изменения несколькими потоками в контексте
одного или нескольких ядер, каждому из них необходимо завладеть мьютексом.
Из-за особенности работы данного примитива синхронизации это будет происходить
последовательно, что обеспечит необходимые требования.

Для захвата владения мьютексом используется функция \lstinline{mutexLock}. Она является блокирующей, что позволяет избежать необходимость периодического
опроса доступности ресурса. Функция ничего не возвращает, а лишь захватывает мьютекс, когда он становится свободным.
Входными параметрами является дескриптор мьютекса \lstinline{handle} типа \lstinline{mutexHandle_t}.

В системе существует аналогичная функция вышеописанной \lstinline{mutexTryLock}. Она является неблокирующей, поэтому при ошибке захвата мьютекса разработчик не должен
взаимодействовать с защищаемыми данными по причине их возможного изменения
в этот момент другими потоками. Тип возвращаемого значения~-- \lstinline{bool}, ожидается \lstinline{true}, если захват мьютекса был произведен, а \lstinline{false}, если
мьютекс занят. Входные параметры соответствуют параметрам функции \lstinline{mutexLock}.

После завершения изменения защищаемых данных мьютекс необходимо освободить, иначе другие потоки будут его бесконечно ждать и нарушится алгоритм работы системы. Функцией разблокировки мьютекса является функция \lstinline{mutexUnlock}.
Она ничего не возвращает, а только освобождает ранее занятый
с помощью функций \lstinline{mutexLock} и \lstinline{mutexTryLock} мьютекс.
В качестве параметров функция принимает дескриптор мьютекса \lstinline{handle} типа \lstinline{mutexHandle_t}, который будет разблокирован.

После окончания работы модуля необходимо закрыть все открытые ресурсы. Для выполнения этой операции используется функция \lstinline{mutexClose}, которая ничего не возвращает, закрывая лишь
ранее открытые ресурсы. В параметры функция принимает дескриптор мьютекса \lstinline{handle} типа \lstinline{mutexHandle_t}, который необходимо закрыть.

Закрытые ресурсы необходимо удалить. Этим занимается функция удаления мьютекса. Процедура \lstinline{mutexDelete} ничего не возвращает, удаляя созданный ресурс. Принимает в параметры
дескриптор мьютекса \lstinline{handle} типа \lstinline{mutexHandle_t}, который необходимо удалить.
После этого ресурс с таким именем можно заново создать.

\subsubsection{Блокировки чтения-записи}

Еще одни примитивом синхронизации является блокировка чтения-записи. Основное различие между блокировкой и мьютексом состоит в том, что блокировка позволяет нескольким программным потокам получать одновременный доступ
к целевому ресурсу на чтение и одиночный на запись, а мьютекс позволяет нескольким программным потокам обращаться к одному ресурсу, но не одновременно. У каждого примитива синхронизации есть свои преимущества и недостатки.

Аналогично очередям сообщений, блокировки чтения-записи тоже могут быть
как обычными, так и межпроцессорными. Разница между данными видами
и особенности взаимодействия с ними описаны выше. Для унификации
дескрипторов рекомендуется использовать тип \lstinline{RWSEM_HANDLE}.

Для создания блокировки чтения-записи необходимо использовать функцию \lstinline{rwsemCreate}, принимающую в качестве параметров уникальное имя блокировки \lstinline{name} типа
\lstinline{const char *}. Функция возвращает дескриптор созданной блокировки типа \lstinline{rwsemHandle_t} при успешной работе, \lstinline{NULL} при ошибке.

Функция \lstinline{rwsemOpen} используется для получения дескриптора ранее созданной блокировки. Функция возвращает дескриптор открытой блокировки типа \lstinline{rwsemHandle_t} при успешной работе, \lstinline{NULL} при ошибке. В качестве параметров она принимает уникальное имя блокировки \lstinline{name} типа \lstinline{const char *}. Необходимо помнить, что открытые
ресурсы в конце работы нужно закрывать.

Функция гарантированного получения блокировки на чтение \lstinline{rwsemLockRead} получает доступ к ресурсу на чтение. В случае если блокировка была ранее занята на запись, система дождется, когда ее освободят, получит право на чтение и только тогда вернет управление. В остальных случаях функция сразу возвратит управление,
увеличив количество текущих блокировок на чтение.
В качестве параметра принимается дескриптор блокировки \lstinline{handle} типа \lstinline{rwsemHandle_t}. Функция ничего не
возвращает, только блокирует ресурс на чтение, если дескриптор был ранее создан или открыт.

Подобная вышеописанной процедуре функция получения блокировки на чтение без ожидания \lstinline{rwsemTryLockRead} получает доступ к ресурсу на чтение только тогда, когда блокировка не была занята на запись. В противном случае доступа к ресурсу нет. В качестве типа возвращаемого значения выступает \lstinline{bool} и результатом будет \lstinline{true}, если произведен захват блокировки, а \lstinline{false}, если блокировка занята. В качестве параметров принимается дескриптор блокировки \lstinline{handle} типа \lstinline{rwsemHandle_t}.

Если блокировка была получена на чтение, то ее необходимо разблокировать с помощью функции \lstinline{rwsemUnlockRead}, которая ничего не возвращает, а только производит освобождение ресурса на чтение, если ранее дескриптор был заблокирован. В качестве параметров принимается дескриптор блокировки \lstinline{handle} типа \lstinline{rwsemHandle_t}.

Помимо чтения данных, существует запись. Разделение данных функций позволяет делать эти две операции независимо друг от друга. Функцией гарантированного получения блокировки на запись
является \lstinline{rwsemLockWrite}. Она получает доступ к ресурсу с возможностью как чтения, так и изменения данных в любом случае. Если блокировка была ранее занята, система дождется, когда ее освободят, получит право на чтение и изменение и только тогда вернет управление. В качестве параметров принимается дескриптор блокировки \lstinline{handle} типа \lstinline{rwsemHandle_t}. Функция ничего не возвращает, только блокирует доступ к данным на чтение и изменение, если дескриптор был ранее создан или открыт.

Похожая на предыдущую функцию процедура получения блокировки на запись без ожидания \lstinline{rwsemTryLockWrite} получает доступ к ресурсу на чтение и изменение только тогда, когда блокировка была ранее свободна. В противном случае доступа к ресурсу нет. В качестве типа возвращаемого значения выступает \lstinline{bool} и результатом будет \lstinline{true}, если произведен захват блокировки, а \lstinline{false}, если блокировка занята. В параметры принимается дескриптор блокировки \lstinline{handle} типа \lstinline{rwsemHandle_t}.

Если блокировка была получена на чтение и изменение, то ее необходимо разблокировать с помощью функции \lstinline{rwsemUnlockWrite}, которая ничего не возвращает, а только производит освобождение ресурса, если блокировка занята. В качестве параметров принимается дескриптор блокировки \lstinline{handle} типа \lstinline{rwsemHandle_t}.

После работы с вышеописанным примитивом синхронизации его необходимо закрыть в случае, если он был открыт с помощью процедуры \lstinline{rwsemOpen}. Данную задачу выполняет функция \lstinline{rwsemClose}, которая принимает в качестве параметра
дескриптор блокировки \lstinline{handle} типа \lstinline{rwsemHandle_t}, который нужно закрыть. Функция ничего не возвращает, только закрывает открытый ранее примитив синхронизации.

Перед завершением работы модуля, все созданные примитивы синхронизации должны быть  удалены. Функцией удаления блокировки является функция
\lstinline{rwsemDelete}, принимающая в качестве параметров дескриптор блокировки \lstinline{handle} типа \lstinline{rwsemHandle_t} для удаления и не возвращающая ничего. Она только удаляет ранее
созданные блокировки.

\subsubsection{Разделяемая память}

Разделяемая память создается внутри каждого модуля системы, блок приема и обработки GOOSE-пакетов не является исключением.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{shmStorage_t}}
    \label{table:func:shmStorages}
    \begin{tabular}{| >{\raggedright}m{0.3\textwidth}
                    | >{\raggedright\arraybackslash}m{0.647\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$SHM_SDRAM$ &
        Для хранения данных используется SDRAM
        \\

        \hline
        \lstinline[]$SHM_FRAM$ &
        Для хранения данных используется FRAM
        \\

        \hline
        \lstinline[]$SHM_SRAM$ &
        Для хранения данных используется SRAM
        \\

        \hline
    \end{tabular}
\end{table}

После старта или перезапуска целевого устройства, ему в части случаев необходимо
проинициализировать внутренние структуры используемых носителей разделяемой памяти.
Эту операцию можно произвести с помощью функции \lstinline{shmInit}, которая ничего
не возвращает, а принимает в качестве входные параметров место хранения данных
\lstinline{storage} типа \lstinline{shmStorage_t}, возможные принимаемые значения
которого описаны в таблице~\ref{table:func:shmStorages}.

\nomenclaturex{SDRAM}{Static Random Access Memory}{статическая память с произвольным доступом}
\nomenclaturex{SDRAM}{Synchronous Dynamic Random Access Memory}{синхронная динамическая память с произвольным доступом}
\nomenclaturex{FRAM}{Ferroelectric Random Access Memory}{сегнетоэлектрическая  память с произвольным доступом}

Если целевое хранилище успешно проинициализировано, его можно использовать
в качестве источника для разделяемой памяти.
Перед тем, как приступить к работе с памятью, необходимо создать дескриптор для доступа к ней. Функция \lstinline{shmCreate} отвечает за создание блока памяти и принимает следующие параметры:

\begin{itemize}
    \item \lstinline{name} типа \lstinline{const char *}~-- уникальное имя блока памяти;
    \item \lstinline{size} типа \lstinline{uint32_t}~-- размер блока памяти;
    \item \lstinline{storage} типа \lstinline{shmStorage_t}~-- тип носителя,
    возможные значения которого описаны в таблице~\ref{table:func:shmStorages}.
\end{itemize}

Функция возвращает дескриптор созданного блока разделяемой памяти типа \lstinline{shmHandle_t} при успешной работе, \lstinline{NULL} при ошибке.

В случае, если память была ранее создана, ее нужно открыть. Для этого создана функция \lstinline{shmOpen}, которая получает дескриптор ранее созданной разделяемой памяти. Она принимает в параметры
уникальное имя блока разделяемой памяти \lstinline{name} типа \lstinline{const char *}, а возвращает возвращает дескриптор открытого блока разделяемой памяти типа \lstinline{shmHandle_t} при успешной работе, \lstinline{NULL} при ошибке.

Для получения базового адреса блока разделяемой памяти используется функция \lstinline{shmMap}, принимающая в качестве параметра дескриптор разделяемой памяти \lstinline{handle} типа \lstinline{shmHandle_t}, чей адрес надо получить, и возвращающая базовый адрес.

Для работы с разделяемой памятью часто необходимо знать ее размер. За получение размера отвечает функция \lstinline{shmSize}, принимающая в качестве параметра дескриптор разделяемой памяти \lstinline{handle} типа \lstinline{shmHandle_t} и возвращающая размер блока типа \lstinline{uint32_t}.

Если работа с регионом разделяемой памяти завершена в текущем модуле, ее необходимо
закрыть. В случае, если текущий модуль был последним, кому нужны данные в этом блоке
памяти, его нужно очистить. Функции закрытия \lstinline{shmClose} и освобождения участка разделяемой памяти \lstinline{shmDelete} ничего не возвращают, а лишь
выполняют свои непосредственные задачи. Также они принимают в качестве параметров дескриптор разделяемой памяти \lstinline{handle} типа \lstinline{shmHandle_t}.

\subsubsection{Задачи}

Задачами является последовательность инструкций, способная выполняться параллельно с другими действиями в системе. Чаще всего каждая задача определяет конкретную часть логики
работы программы. Они могут быть синхронизированы, зависимы друг от друга, работать параллельно. По меньшей мере одна задача создается в любой системе, в которой происходит ее запуск, однако разрабатываемое программное обеспечение является многозадачным. В блоке приема и обработки GOOSE-пакетов используется по одной задачи для каждого сетевого интерфейса.

Обычно задачи исполняются в независимых друг от друга потоках среды исполнения
или операционной системы.

Для начала работы с задачей ее необходимо создать. Сделать это можно с помощью функции \lstinline{taskCreate}. В качестве входных параметров принимаются:

\begin{itemize}
    \item \lstinline{taskFunc} типа \lstinline{taskFunc_t}~-- функция, которая будет выполнена в качестве новой задачи;
    \item \lstinline{prio} типа \lstinline{uint32_t}~-- приоритет создаваемой задачи, большее число соответствует высшему приоритету, значение \lstinline{TASK_PRIO_IDLE} является зарезервированным;
    \item \lstinline{arg} типа \lstinline{void *}~-- аргумент, передаваемый в функцию \lstinline{taskFunc} при ее исполнении;
    \item \lstinline{param} типа \lstinline{taskParam_t *}~-- указатель на опциональные параметры; если передан \lstinline{NULL}~-- будут использованы параметры по умолчанию для целевой операционной системы.
\end{itemize}

Функция \lstinline{taskCreate} возвращает дескриптор созданной задачи типа \lstinline{taskHandle_t} или \lstinline{NULL} при ошибке.

Тип \lstinline{taskFunc_t} описывает функцию обратного вызова задачи, которая ничего
не возвращает и принимает один аргумент типа \lstinline{void *}. Этот параметр
обычно используется для передачи пользовательских данных в функцию.

Структура типа \lstinline{taskParam_t} определяет параметры задачи и включает в себя \lstinline{name}~-- имя задачи типа \lstinline{const char *}, для которого в системе
определена максимальная длина имени задачи \lstinline{TASK_MAX_NAME_SIZE}, равная 16, и размер стека задачи в байтах \lstinline{stackSize} типа \lstinline{uint32_t}.

Функция \lstinline{taskWait} ожидает какого-либо события от другой задачи, к примеру, информацию о завершении работы с разделяемой памятью. В качестве параметров ничего не принимает, возвращает аргумент типа \lstinline{uint32_t}, который был передан в функцию \lstinline{taskNotify}, запустившую ее на дальнейшее выполнение.

Функция \lstinline{taskNotify} занимается оповещением задач о возникновении ожидаемого в функции \lstinline{taskWait} события. Первым параметром она принимает \lstinline{handle} типа \lstinline{taskHandle_t}~-- дескриптор задачи, которую необходимо оповестить, вторым~-- аргумент для оповещаемой задачи \lstinline{notify} типа \lstinline{uint32_t}.
Данная функция не имеет возвращаемого значения.

Часто возникает ситуация, когда система перестает справляться с заданным функционалом из-за большого количества параллельно работающих задач. Одним
из решений в такой ситуации является переход задачи в режим ожидания на заданный интервал времени, если ей нечего обрабатывать. Такую возможность предоставляет
функция \lstinline{taskSleep}, принимающая в качестве параметра \lstinline{sleepMs} типа \lstinline{uint32_t}~-- количество миллисекунд ожидания. Функция ничего не возвращает, а
только переводит задачу в режим ожидания на заданный интервал времени.

Для принудительного удаления задачи из системы можно использовать функцию \lstinline{taskDelete}. Она принимает в качестве параметра дескриптор задачи
\lstinline{handle} типа \lstinline{taskHandle_t}, удаляет ранее созданную задачу и ничего не возвращает.

\subsubsection{Таймеры}

Таймеры в системе позволяют отсчитывать конкретное время, по окончании которого нужно выполнить запланированные действия. Таймер должен минимизировать потребление вычислительных ресурсов, практически мгновенно включаться и выключаться, при этом сбрасывать свое состояние и обязательно быть достаточно точным.

Перед началом работы с таймером его необходимо создать. Для этого используется функция \lstinline{timerCreate}, принимающая следующие параметры:

\begin{itemize}
    \item \lstinline{cb} типа \lstinline{timerCbFunc_t}~-- обработчик события от таймера;
    \item \lstinline{arg} типа \lstinline{void *}~-- аргумент, который будет передан в функцию-обработчик;
    \item \lstinline{delay} типа \lstinline{uint32_t}~-- длительность первого периода, в микросекундах;
    \item \lstinline{period} типа \lstinline{uint32_t}~-- период работы таймера в микросекундах после первого срабатывания; при нулевом значении таймер сработает только один раз.
\end{itemize}

Функция возвращает дескриптор созданного таймера типа \lstinline{timerHandle_t} или \lstinline{NULL} при возникновении ошибки.

Тип \lstinline{timerCbFunc_t} описывает функцию обратного вызова таймера, которая
ничего не возвращает и принимает один аргумент типа \lstinline{void *}. Этот
параметр обычно используется для передачи пользовательских данных в
функцию.

После очередного истечения периода таймера должны выполняться запланированные логикой системы действия. В случае, если их нужно переопределить после создания дескриптора, существует процедура замены функции-обработчика
\lstinline{timerSetCallback}. В качестве входных параметров она принимает дескриптор таймера \lstinline{handle} типа \lstinline{timerHandle_t} и функцию-обработчик
\lstinline{cb} типа \lstinline{timerCbFunc_t}. Данная функция ничего не возвращает.

В процессе работы программы иногда требуется изменить время первого срабатывания таймера. Для этого есть специальная функция \lstinline{timerSetDelay}, которая ничего не возвращает,
а в параметры принимает дескриптор таймера \lstinline{handle} типа \lstinline{timerHandle_t} и новое значение времени \lstinline{delay} типа \lstinline{uint32_t} в микросекундах.

Помимо первого срабатывания может возникнуть потребность изменения периода работы таймера. Функция \lstinline{timerSetPeriod} позволяет установить новый период. Она ничего не возвращает,
а в параметры принимает дескриптор таймера \lstinline{handle} типа \lstinline{timerHandle_t} и новый период \lstinline{period} типа \lstinline{uint32_t} в микросекундах.

Чтобы таймер начал отсчитывать заданные интервалы времени, его необходимо запустить. Это делается с помощью функции \lstinline{timerStart}, которая принимает в качестве входного параметра
дескриптор таймера \lstinline{handle} типа \lstinline{timerHandle_t} и ничего не возвращает, запуская ранее созданный таймер.

По окончании работы модуля нужно закрыть все ресурсы, в том числе и остановить таймер. Это делается с помощью функции \lstinline{timerStop}, которая ничего не возвращает,
а только останавливает ранее работающий таймер, и принимает во входные параметры дескриптор таймера \lstinline{handle} типа \lstinline{timerHandle_t}.

Функция удаления таймера \lstinline{timerDelete} ничего не возвращает, удаляя ранее созданный таймер, принимает во входные параметры дескриптор таймера \lstinline{handle} типа \lstinline{timerHandle_t}.

\subsubsection{Передача данных по сети}

Сокеты~-- программный интерфейс для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одном вычислительном узле, так и на различных, связанных между собой сетью. Сокет~-- абстрактный объект, представляющий точку соединения.

Для работы с сокетами их необходимо создать с помощью функции \lstinline{netSocket}.
Она принимает следующие параметры:

\begin{itemize}
    \item \lstinline{domain} типа \lstinline{netDomain_t}~-- семейство протоколов,
    которое будет использоваться для связи;
    \item \lstinline{type} типа \lstinline{netType_t}~-- семантика устанавливаемого соединения;
    \item \lstinline{protocol} типа \lstinline{uint16_t}~-- код протокола, используемый при работе с сырыми сокетами в качестве EtherType.
\end{itemize}

Данная функция возвращает указатель на сокет-дескриптор типа \lstinline{netSock_t} при успешном создании, \lstinline{NET_INVALID_SOCKET} при ошибке.

Тип \lstinline{netDomain_t} является перечислением. Его возможные значения
и их описание приведены в таблице~\ref{table:func:netDomain}.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{netDomain_t}}
    \label{table:func:netDomain}
    \begin{tabular}{| >{\raggedright}m{0.24\textwidth}
                    | >{\raggedright\arraybackslash}m{0.707\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$NET_AF_INET$ &
        Семейство протоколов IP
        \\

        \hline
        \lstinline[]$NET_AF_PACKET$ &
        Семейство протоколов канального уровня модели OSI
        \\

        \hline
    \end{tabular}
\end{table}

\nomenclaturex{IP}{Internet Protocol}{протокол интернета}

Тип \lstinline{netType_t} является перечислением, которое описывает тип создаваемого
сокета. Его возможные значения приведены в таблице~\ref{table:func:netType}.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{netType_t}}
    \label{table:func:netType}
    \begin{tabular}{| >{\raggedright}m{0.28\textwidth}
                    | >{\raggedright\arraybackslash}m{0.667\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$NET_SOCK_STREAM$ &
        Предоставление двустороннего, надежного потока байтов на основе установления соединения
        \\

        \hline
        \lstinline[]$NET_SOCK_DGRAM$ &
        Поддержка ненадежных сообщений с ограниченной длиной без установки соединения
        \\

        \hline
        \lstinline[]$NET_SOCK_RAW$ &
        Предоставление доступа к сырым данным сетевого протокола
        \\

        \hline
    \end{tabular}
\end{table}

В процессе работы имеется возможность получения опций сокета. За это отвечает функция \lstinline{netGetSockOpt}, которая принимает следующие параметры:

\begin{itemize}
    \item \lstinline{s} типа \lstinline{netSock_t}~-- дескриптор сокета;
    \item \lstinline{level} типа \lstinline{netProtocol_t}~-- уровень протокола, на котором описана опция;
    \item \lstinline{op} типа \lstinline{netOptions_t}~-- номер опции для получения;
    \item \lstinline{p_buf} типа \lstinline{void *}~-- указатель на буфер, в который нужно поместить запрошенное значение опции при возврате;
    \item \lstinline{p_buf_size} типа \lstinline{uint32_t *}~-- указатель на поле, в котором при вызове содержится размер буфера
    \lstinline{p_buf}, а при возврате~-- реальный размер возвращаемого значения.
\end{itemize}

Тип возвращаемого значения функции получения параметров сокета~-- \lstinline{netReturnCode_t}.
Это перечисление используется практически во всех функциях сетевого стека.
Ожидается, что \lstinline{NET_OK} будет возвращен при успешном выполнении функции
или отрицательное число, соответствующее одному из элементов таблицы~\ref{table:func:netRetCode}, при ошибке.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{netReturnCode_t}}
    \label{table:func:netRetCode}
    \begin{tabular}{| >{\raggedright}m{0.5\textwidth}
                    | >{\raggedright\arraybackslash}m{0.447\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$NET_OK$ &
        Отсутствие ошибок
        \\

        \hline
        \lstinline[]$NET_ERROR_UNKNOWN$ &
        Неизвестная ошибка
        \\

        \hline
        \lstinline[]$NET_ERROR_HW_FAIL$ &
        Ошибка оборудования
        \\

        \hline
    \end{tabular}
\end{table}

Тип \lstinline{netProtocol_t} представляет собой перечисление, описывающее различные уровни протоколов.
Возможные значения этого типа приведены в таблице~\ref{table:func:netProtocol}.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{netProtocol_t}}
    \label{table:func:netProtocol}
    \begin{tabular}{| >{\raggedright}m{0.4\textwidth}
                    | >{\raggedright\arraybackslash}m{0.547\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$NET_IPPROTO_IP$ &
        Уровень протокола IP
        \\

        \hline
        \lstinline[]$NET_IPPROTO_TCP$ &
        Уровень протокола TCP
        \\

        \hline
        \lstinline[]$NET_IPPROTO_UDP$ &
        Уровень протокола UDP
        \\

        \hline
        \lstinline[]$NET_IPPROTO_RAW$ &
        Уровень протокола канального уровня
        \\

        \hline
    \end{tabular}
\end{table}

\nomenclaturex{TCP}{Transmission Control Protocol}{протокол управления передачей}
\nomenclaturex{UDP}{User Datagram Protocol}{протокол пользовательских датаграмм}

Тип \lstinline{netOptions_t} представляет собой перечисление, описывающее различные
опции, которые могут быть получены или установлены для определенного сокета
с помощью функций \lstinline{netGetSockOpt} или \lstinline{netSetSockOpt}
соответственно. Описание возможных значений этого типа представлено в таблице~\ref{table:func:netOptions}.

Помимо того, что необходимо получать параметры сокетов, их можно устанавливать с помощью функции \lstinline{netSetSockOpt}. Она принимает в параметры следующие аргументы:

\begin{itemize}
    \item \lstinline{s} типа \lstinline{netSock_t}~-- дескриптор сокета;
    \item \lstinline{level} типа \lstinline{netProtocol_t}~-- уровень протокола, на котором описана опция;
    \item \lstinline{op} типа \lstinline{netOptions_t}~-- номер опции для изменения;
    \item \lstinline{p_buf} типа \lstinline{void *}~-- указатель на буфер, из которого нужно прочитать устанавливаемое значение опции;
    \item \lstinline{buf_size} типа \lstinline{uint32_t}~-- размер буфера \lstinline{p_buf}.
\end{itemize}

Тип возвращаемого значения функции установки параметров сокета~-- \lstinline{netReturnCode_t}, ожидается \lstinline{NET_OK} при успешном выполнении функции,
отрицательное число из таблицы~\ref{table:func:netRetCode}~-- при ошибке.

Для получения данных из сокета используется функция \lstinline{netRecv} со следующими параметрами:

\begin{itemize}
    \item \lstinline{s} типа \lstinline{netSock_t}~-- дескриптор сокета;
    \item \lstinline{p_buf} типа \lstinline{void *}~-- указатель на буфер для записи полученных данных из сокета;
    \item \lstinline{buf_size} типа \lstinline{uint32_t}~-- размер буфера для записи полученных данных из сокета;
    \item \lstinline{flags} типа \lstinline{uint32_t}~-- комбинация битовых флагов, управляющих режимами чтения. Если установлен флаг \lstinline{NET_MSG_PEEK}, то данные не удаляются и могут быть считаны последующим вызовом, иначе то, что было получено, будет автоматически удалено из сокета.
\end{itemize}

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{netOptions_t}}
    \label{table:func:netOptions}
    \begin{tabular}{| >{\raggedright}m{0.3\textwidth}
                    | >{\raggedright\arraybackslash}m{0.647\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$NET_SO_REUSEADDR$ &
        Включение возможности создания дополнительной привязки к уже используемому порту TCP или UDP
        \\

        \hline
        \lstinline[]$NET_SO_TYPE$ &
        Тип сокета, должен быть одним из элементов \lstinline[]$netType_t$
        \\

        \hline
        \lstinline[]$NET_SO_ERROR$ &
        Получение и очистка последней ошибки, возникшей при работе с сокетом
        \\

        \hline
        \lstinline[]$NET_SO_RCVTIMEO$ &
        Указание минимального времени ожидания при приеме до генерации сообщения об ошибке
        \\

        \hline
        \lstinline[]$NET_SO_SNDTIMEO$ &
        Указание минимального времени ожидания при отправке до генерации сообщения об ошибке
        \\

        \hline
        \lstinline[]$NET_SO_IFDEVICE$ &
        Привязка сокет к интерфейсу по индексу интерфейса
        \\

        \hline
        \lstinline[]$NET_SO_BLOCKING$ &
        Установка блокирующего или неблокирующего режима сокета
        \\

        \hline
    \end{tabular}
\end{table}

Тип возвращаемого значения функции установки параметров сокета~-- \lstinline{int32_t}, ожидается число считанных байт при успешном чтении, отрицательное число из таблицы~\ref{table:func:netRetCode}~-- при ошибке.

В процессе работы системы необходимо закрывать те соединения, которые более не используются.
За это отвечает функция \lstinline{netShutDown}, которая принимает в качестве входных
параметров дескриптор сокета \lstinline{s} типа \lstinline{netSock_t} и значение \lstinline{how} типа \lstinline{netShut_t}, указывающее на ограничение, накладываемое на
сокет. Функция имеет тип возвращаемого значения \lstinline{netReturnCode_t}. Ожидается \lstinline{NET_OK} при успешном выполнении, отрицательное число из таблицы~\ref{table:func:netRetCode}~-- при ошибке.

Тип \lstinline{netShut_t} представляет собой перечисление способов закрытия соединения. Его возможные варианты описаны в таблице~\ref{table:func:netShut}.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{netShut_t}}
    \label{table:func:netShut}
    \begin{tabular}{| >{\raggedright}m{0.4\textwidth}
                    | >{\raggedright\arraybackslash}m{0.547\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$NET_SHUT_RD$ &
        Запрет приема данных
        \\

        \hline
        \lstinline[]$NET_SHUT_WR$ &
        Запрет отправки данных
        \\

        \hline
        \lstinline[]$NET_SHUT_RDWR$ &
        Запрет приема и отправки данных
        \\

        \hline
    \end{tabular}
\end{table}

Функция \lstinline{netClose} закрывает созданный сокет и разрывает все соединения с этим сокетом. В качестве входного параметра она принимает
закрываемый дескриптор сокета \lstinline{s} типа \lstinline{netSock_t}. Функция имеет тип возвращаемого значения \lstinline{netReturnCode_t}. Ожидается \lstinline{NET_OK} при успешном выполнении,
отрицательное число из таблицы~\ref{table:func:netRetCode}~-- при ошибке.

В процессе работы системы возникает необходимость преобразования IP-адреса из сетевого формата данных в его представление в виде строки. За это отвечает функция
\lstinline{netInetNtop}, которая принимает следующие параметры:

\begin{itemize}
    \item \lstinline{af} типа \lstinline{netDomain_t}~-- протокол связи, адрес которого будет преобразовываться;
    \item \lstinline{src} типа \lstinline{const void *}~-- сетевой формат представления преобразуемого адреса;
    \item \lstinline{dst} типа \lstinline{char *}~-- строка, в которую сохраняется результат преобразования адреса из сетевого формата в его обычное представление
    в виде строки;
    \item \lstinline{size} типа \lstinline{uint32_t}~-- размер результирующей строки, куда будет записано текстовое представление в случае успеха.
\end{itemize}

Данная функция возвращает указатель на строку \lstinline{dst} при успешном преобразовании, \lstinline{NULL} при ошибке.

Помимо функции \lstinline{netInetNtop} в системе используется \lstinline{netInetPton}, которая преобразует строки символов в сетевой формат адреса. В качестве входных
параметров она принимает следующие значения:

\begin{itemize}
    \item \lstinline{af} типа \lstinline{netDomain_t}~-- протокол связи, адрес которого будет преобразовываться;
    \item \lstinline{src} типа \lstinline{const char *}~-- тестовое представление адреса;
    \item \lstinline{dst} типа \lstinline{void *}~-- указатель на буфер, в который копируется результат преобразования. Минимальный размер буфера~-- четыре байта.
\end{itemize}

Данная функция возвращает значение типа \lstinline{int32_t}, которое является:

\begin{itemize}
    \item положительным числом при успешном преобразовании;
    \item отрицательным значением, если преобразование адресов указанного протокола связи не поддерживается;
    \item нулем при некорректной строке символов.
\end{itemize}

\subsection{Модуль \moduleLog}

Уведомления о работоспособности или о возникновении ошибки необходимы на всех этапах разработки и тестирования программного обеспечения. В разрабатываемой системе
были созданы специальные макросы и
функции, которые это обеспечивают.

Функция \lstinline{logLevel} выводит отладочную информацию на все поддерживаемые
носители и принимает в качестве параметров:

\begin{itemize}
    \item \lstinline{module_name} типа \lstinline{const char *}~-- имя модуля источника записи сообщения;
    \item \lstinline{level} типа \lstinline{LogLevel_t}~-- уровень записи;
    \item \lstinline{format} типа \lstinline{const char *}~-- формат сообщения с отформатированным заголовком, аналогичный стандартной функции \lstinline{printf};
    \item аргументы, которые используются при форматировании сообщения.
\end{itemize}

Тип \lstinline{LogLevel_t} является перечислением и имеет следующие поля, представленные в таблице~\ref{table:func:logLevel}.

\begin{table}[ht]
    \caption{Элементы перечисления \lstinline{LogLevel_t}}
    \label{table:func:logLevel}
    \begin{tabular}{| >{\raggedright}m{0.45\textwidth}
                    | >{\raggedright\arraybackslash}m{0.497\textwidth}|}
        \hline
        \centering Название & \centering\arraybackslash Описание \\

        \hline
        % Based on https://tex.stackexchange.com/a/352349/139966
        \lstinline[]$LOG_LEVEL_CRITICAL$ &
        Критическая ошибка
        \\

        \hline
        \lstinline[]$LOG_LEVEL_ERROR$ &
        Ошибка
        \\

        \hline
        \lstinline[]$LOG_LEVEL_WARNING$ &
        Предупреждение
        \\

        \hline
        \lstinline[]$LOG_LEVEL_INFO$ &
        Информационное сообщение
        \\

        \hline
        \lstinline[]$LOG_LEVEL_DEBUG$ &
        Отладочное сообщение
        \\

        \hline
        \lstinline[]$LOG_LEVEL_NONE$ &
        Сообщение не выводится
        \\

        \hline
    \end{tabular}
\end{table}

Помимо функции \lstinline{logLevel} используются макросы для форматирования логов. Они все принимают первым параметром сообщение для форматирования, а вторым~-- параметры для
форматирования. Выделяется шесть видов макросов, которые определяют уровень
важности сообщения в соответствии с таблицей~\ref{table:func:cmTypes}
и последней буквой в их названии: \lstinline{logMsgC}, \lstinline{logMsgE}, \lstinline{logMsgW},
\lstinline{logMsgI}, \lstinline{logMsgD} и \lstinline{logMsgN}.

\subsection{Модуль \moduleCfg}

Модуль \moduleCfg\ является важным модулем системы. Он обеспечивает
работу с входными настройками устройства, проверяет их целостность
и преобразует их в тот вид, который необходим для дальнейшей работы.
Поэтому все функции, которые относятся к нему, имеют префикс \lstinline{conf_}.

Данные, которые приходят в систему, представляют собой пакеты или \cid-файлы, а для сохранения данных в память необходимо преобразовать информацию в подходящий формат.
Функция преобразования строки в шестнадцатеричном виде в бинарные данные \lstinline{conf_convertHexStringToInt} имеет тип возвращаемого значения \lstinline{bool}. возвращает
Значение \lstinline{true} будет получено при успешном преобразовании, а \lstinline{false}~-- при ошибке конвертации. В качестве входных параметров функция принимает строку \lstinline{hex} типа
\lstinline{const char *} в шестнадцатеричном виде (к примеру <<A10ECD013D01>>, <<acd100adcf91>> или  <<Ad4500Ff27cc>>) и указатель на буфер
\lstinline{bin} типа \lstinline{uint8_t *} для записи результирующего набора байт.

Функция \lstinline{conf_convertMacToCorrectFormat} преобразует MAC-адрес вида <<XX-XX-XX-XX-XX-XX>> к виду <<XXXXXXXXXXXX>>. Она имеет тип
возвращаемого значения \lstinline{bool}. Значение \lstinline{true} будет получено при успешном преобразовании, а \lstinline{false}~-- при ошибке конвертации. В качестве входных
параметров функция принимает указатель на строку \lstinline{mac} типа \lstinline{const char *} с MAC-адресом, который необходимо преобразовать в другой формат, и
указатель на буфер \lstinline{result_mac} типа \lstinline{char *} размером \lstinline{NET_MAC_ADDRESS_SIZE * 2} для получения результирующего адреса.

Функция \lstinline{conf_processExtRefGoose_private} предназначена для заполнения структур, необходимые для формирования GOOSE-конфигурации, и принимает в качестве параметров \lstinline{reader}
типа \lstinline{xmlTextReaderPtr}~-- дескриптор \lstinline{xmlReader} библиотеки \libXml\ и имя \lstinline{name} типа \lstinline{const xmlChar *} элемента строки в \cid-файле.
Текущая функция имеет тип возвращаемого значения \lstinline{bool}. Ожидается \lstinline{true} при успешном формировании структур, \lstinline{false}~-- при
возникновении ошибок.

Функция \lstinline{conf_writeShmGooseCfgData_private} записывает конфигурацию в память блока приема и обработки GOOSE-пакетов. Она возвращает указатель на конец записанных в память данных типа \lstinline{void *}, \lstinline{NULL} при ошибке. В качестве входных параметров принимает указатель \lstinline{ptr_config} типа
\lstinline{const void *} на начало в памяти, куда надо записывать данные.

Вспомогательная функция для работы со списком строк из \cid-файла \lstinline{conf_parseGooseConf_private} ничего не принимает и имеет тип возвращаемого
значения \lstinline{bool}. Ожидается \lstinline{true} при  успешной обработке строки, \lstinline{false}~-- при ошибке.

Еще одна вспомогательная функция для работы со списком строк из \cid-файла \lstinline{conf_parseGooseIntAddrArray_private} имеет тип возвращаемого
значения \lstinline{bool}. Ожидается \lstinline{true} при  успешной обработке строки, \lstinline{false}~-- при ошибке. В качестве входных данных используются следующие параметры:

\begin{itemize}
    \item \lstinline{goose_string} типа \lstinline{const char *}~-- указатель на строку \cid-файла для разбора;
    \item \lstinline{ied_name} типа \lstinline{const char *}~-- указатель на параметр <<iedName>> в \cid-файле;
    \item \lstinline{src_ld_inst} типа \lstinline{const char *}~-- указатель на параметр <<srcLdInst>> в \cid-файле;
    \item \lstinline{src_cb_name} типа \lstinline{const char *}~-- указатель на параметр <<srcCBName>> в \cid-файле.
\end{itemize}

Функцией формирования строки для получения индекса переменной является \lstinline{conf_gettingValueIdx}, которая имеет тип возвращаемого значения \lstinline{bool} и
ожидает \lstinline{true} при корректном формировании строки, а \lstinline{false}~-- при ошибке формирования. В качестве входных параметров в функцию поступают следующие значения:

\begin{itemize}
    \item \lstinline{res_buf} типа \lstinline{char *}~-- буфер, куда записывается результат формирования строки;
    \item \lstinline{name} типа \lstinline{const char *}~-- константное начало строки, обычно <<SYS/LLN0.GOOSE>>;
    \item \lstinline{cdc_type} типа \lstinline{char *}~-- тип CDC в текстовом представлении;
    \item \lstinline{prefix} типа \lstinline{char *}~-- цифра, которая позволяет определить, в какой элемент массива должна быть помещена переменная; нумерация начинается с единицы;
    \item \lstinline{da_name} типа \lstinline{char *}~-- имя DA, по которому необходимо определить индекс переменной общей модели и ее тип.
\end{itemize}

\nomenclaturex{CDC}{Common Data Class}{общий класс данных}
\nomenclaturex{DA}{Data attribute}{атрибут данных}

Как было сказано выше, в системе находится большое количество списков, для упрощения работы с ними, учитывая особенности каждого, были созданы вспомогательные функции.
Функция \lstinline{conf_addNestingsToTheList} предназначена для добавления уровней вложенности в список и имеет тип возвращаемого значения \lstinline{bool}. В результате ее работы ожидается \lstinline{true}
при успешной записи уровня вложенности, \lstinline{false}~-- при ошибке. В качестве входных параметров функция принимает указатель на значение вложенности для текущего уровня
типа \lstinline{char *}, который необходимо добавить в список, и указатель на \lstinline{vars_info} типа \lstinline{gooseVarsInfo_t}, в который надо
добавить списки вложенности.

Функцией поиска необходимого элемента в списке является \lstinline{conf_searchGooseConfigurationByGoCbRef_private}. Она возвращает указатель на элемент списка типа \lstinline{gooseConfigInfo_t}, в котором найдено искомое значение, \lstinline{NULL}, если искомое значение не найдено. В качестве входных параметров принимается значение \lstinline{go_cb_ref} типа
\lstinline{const char *}, которое необходимо найти в списке.

После работы модуля \moduleCfg\ с параметрами GOOSE-пакетов и \cid-файлами необходима полная очистка вспомогательных ресурсов модуля, которой занимается функция
\lstinline{conf_clearMemory_private}. Она ничего не принимает в качестве аргументов и ничего не возвращает, а только освобождает занятую память.

Еще одна функция очистки ресурсов~-- \lstinline{conf_clearGooseConfig_private}, которая принимает в качестве параметров указатель \lstinline{goose_config_info} типа
\lstinline{gooseConfigInfo_t} на ресурсы, которые необходимо освободить, и ничего не возвращает.

В системе также существуют функции для очистки конкретных ресурсов, к примеру секции vars. Этим занимается функция \lstinline{conf_clearOnlyVarsInfo},
принимающая в качестве параметров указатель на ресурсы \lstinline{vars_info} типа \lstinline{gooseVarsInfo_t}, которые необходимо освободить. Она ничего не возвращает.

Функция, отвечающая за очистку строк содержащих атрибуты, полученных в результате работы библиотеки \libXml, \lstinline{gooseAttrFree} в качестве входных
параметров принимает указатель \lstinline{goose_info} типа \lstinline{gooseInfo_t} на ресурсы, которые необходимо освободить, и ничего не возвращает.

\subsection{Модуль \moduleXml}

В \cid-файлах строки хранятся под определенным тэгом. Следующая рассматриваемая функция преобразовывает и разбирает одну строку \cid-файла с тэгом \lstinline{inAddr}.
Функция \lstinline{conf_parseGooseIntAddr_private} принимает в качестве входных параметров следующие значения:

\begin{itemize}
    \item \lstinline{goose_string} типа \lstinline{const char *}~-- указатель на строку \cid-файла для разбора;
    \item \lstinline{ied_name} типа \lstinline{const char *}~-- указатель на параметр <<iedName>> в \cid-файле;
    \item \lstinline{src_ld_inst} типа \lstinline{const char *}~-- указатель на параметр <<srcLdInst>> в \cid-файле;
    \item \lstinline{src_cb_name} типа \lstinline{const char *}~-- указатель на параметр <<srcCBName>> в \cid-файле.
\end{itemize}

Функция возвращает указатель на заполненную данными структуру типа \lstinline{gooseConfigInfo_t}, а \lstinline{NULL} при ошибке.
Успешно возвращенные данные нужно освободить с помощью системной процедуры
\lstinline{free} после проведения необходимой обработки.

Функция разбора части GOOSE-секции vars \cid-файла для модуля \moduleCfg\ \lstinline{conf_parseGooseVars_private} имеет тип возвращаемого значения \lstinline{bool}. Ожидается \lstinline{true} при успешном разборе строки, \lstinline{false} при ошибке разбора или некорректном формате строки. В качестве входных параметров текущая
функция принимает следующие аргументы:

\begin{itemize}
    \item \lstinline{idx} типа \lstinline{uint32_t}~-- индекс начала секции vars;
    \item \lstinline{goose_string} типа \lstinline{const char *}~-- строка из \cid-файла;
    \item \lstinline{goose_config_info} типа \lstinline{gooseConfigInfo_t *}~-- указатель на структуру, в которую необходимо записать результирующие данные.
\end{itemize}

Структура типа \lstinline{gooseConfigInfo_t} представляет собой элемент списка для хранения GOOSE-конфигурации и включает следующие поля:

\begin{itemize}
    \item \lstinline{next} типа \lstinline{gooseConfigInfo_t *}~-- следующий элемент списка;
    \item \lstinline{confRev} типа \lstinline{uint32_t}~-- номер версии конфигурации GoCB;
    \item \lstinline{source} типа \lstinline{uint32_t}~-- идентификатор сетевого интерфейса, по которому ожидается получение GOOSE-пакета текущей конфигурации;
    \item \lstinline{appId} типа \lstinline{uint16_t}~-- ожидаемый идентификатор приложения, которое отправило пакет;
    \item \lstinline{goCbRefLength} типа \lstinline{uint8_t}~-- длина полезных данных объектной ссылки на GoCB;
    \item \lstinline{varsSize} типа \lstinline{uint8_t}~-- количество элементов в списке \lstinline{headVarsInfo};
    \item \lstinline{dstMac} типа \lstinline{uint8_t}~-- мультикаcт-MAC-адрес, указанный в GOOSE-сообщении в качестве целевого. Используется для фильтрации мультикаст-сообщений на более ранних этапах приема. Является массивом из \lstinline{NET_MAC_ADDRESS_SIZE} элементов;
    \item \lstinline{goCbRef} типа \lstinline{char *}~-- объектная ссылка на GoCB;
    \item \lstinline{headVarsInfo} типа \lstinline{gooseVarsInfo_t}~-- голова списка переменных, находящихся в GOOSE, которые должны быть скопированы в общую модель.
\end{itemize}

Структура типа \lstinline{gooseVarsInfo_t} представляет собой список переменных, находящихся в GOOSE-конфигурации, которые должны быть скопированы в общую модель,
и включает следующие поля:

\begin{itemize}
    \item \lstinline{next} типа \lstinline{gooseVarsInfo_t *}~-- следующий элемент списка;
    \item \lstinline{cdmIdx} типа \lstinline{uint32_t}~--  индекс общей модели данных, по которому находится переменная, куда должно быть
    записано значение, пришедшее в соответствующей позиции соответствующего GOOSE-пакета;
    \item \lstinline{cdmType} типа \lstinline{uint8_t}~-- тип переменной в общей модели данных;
    \item \lstinline{nestingCount} типа \lstinline{uint8_t}~-- количество смещений;
    \item \lstinline{headNestingInfo} типа \lstinline{gooseNestingInfo_t}~-- голова списка смещений.
\end{itemize}

Список смещений внутри ASN.1-пакета указывает на местонахождения значения в ASN.1-пакете. Он представлен структурой типа \lstinline{headNestingInfo}, включающей в себя:

\begin{itemize}
    \item следующий элемент списка \lstinline{next} типа \lstinline{gooseNestingInfo_t};
    \item значение одного смещения \lstinline{nesting} типа \lstinline{uint8_t}.
\end{itemize}

\nomenclaturex{ASN.1}{Abstract Syntax Notation One}{язык для описания абстрактного синтаксиса данных}
